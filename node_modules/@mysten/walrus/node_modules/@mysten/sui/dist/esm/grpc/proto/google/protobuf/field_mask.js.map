{
  "version": 3,
  "sources": ["../../../../../../src/grpc/proto/google/protobuf/field_mask.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// @generated by protobuf-ts 2.9.6 with parameter force_server_none,optimize_code_size,ts_nocheck\n// @generated from protobuf file \"google/protobuf/field_mask.proto\" (package \"google.protobuf\", syntax proto3)\n// tslint:disable\n// @ts-nocheck\n//\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\nimport { typeofJsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonValue } from \"@protobuf-ts/runtime\";\nimport { lowerCamelCase } from \"@protobuf-ts/runtime\";\nimport type { JsonReadOptions } from \"@protobuf-ts/runtime\";\nimport type { JsonWriteOptions } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * `FieldMask` represents a set of symbolic field paths, for example:\n *\n *     paths: \"f.a\"\n *     paths: \"f.b.d\"\n *\n * Here `f` represents a field in some root message, `a` and `b`\n * fields in the message found in `f`, and `d` a field found in the\n * message in `f.b`.\n *\n * Field masks are used to specify a subset of fields that should be\n * returned by a get operation or modified by an update operation.\n * Field masks also have a custom JSON encoding (see below).\n *\n * # Field Masks in Projections\n *\n * When used in the context of a projection, a response message or\n * sub-message is filtered by the API to only contain those fields as\n * specified in the mask. For example, if the mask in the previous\n * example is applied to a response message as follows:\n *\n *     f {\n *       a : 22\n *       b {\n *         d : 1\n *         x : 2\n *       }\n *       y : 13\n *     }\n *     z: 8\n *\n * The result will not contain specific values for fields x,y and z\n * (their value will be set to the default, and omitted in proto text\n * output):\n *\n *\n *     f {\n *       a : 22\n *       b {\n *         d : 1\n *       }\n *     }\n *\n * A repeated field is not allowed except at the last position of a\n * paths string.\n *\n * If a FieldMask object is not present in a get operation, the\n * operation applies to all fields (as if a FieldMask of all fields\n * had been specified).\n *\n * Note that a field mask does not necessarily apply to the\n * top-level response message. In case of a REST get operation, the\n * field mask applies directly to the response, but in case of a REST\n * list operation, the mask instead applies to each individual message\n * in the returned resource list. In case of a REST custom method,\n * other definitions may be used. Where the mask applies will be\n * clearly documented together with its declaration in the API.  In\n * any case, the effect on the returned resource/resources is required\n * behavior for APIs.\n *\n * # Field Masks in Update Operations\n *\n * A field mask in update operations specifies which fields of the\n * targeted resource are going to be updated. The API is required\n * to only change the values of the fields as specified in the mask\n * and leave the others untouched. If a resource is passed in to\n * describe the updated values, the API ignores the values of all\n * fields not covered by the mask.\n *\n * If a repeated field is specified for an update operation, new values will\n * be appended to the existing repeated field in the target resource. Note that\n * a repeated field is only allowed in the last position of a `paths` string.\n *\n * If a sub-message is specified in the last position of the field mask for an\n * update operation, then new value will be merged into the existing sub-message\n * in the target resource.\n *\n * For example, given the target message:\n *\n *     f {\n *       b {\n *         d: 1\n *         x: 2\n *       }\n *       c: [1]\n *     }\n *\n * And an update message:\n *\n *     f {\n *       b {\n *         d: 10\n *       }\n *       c: [2]\n *     }\n *\n * then if the field mask is:\n *\n *  paths: [\"f.b\", \"f.c\"]\n *\n * then the result will be:\n *\n *     f {\n *       b {\n *         d: 10\n *         x: 2\n *       }\n *       c: [1, 2]\n *     }\n *\n * An implementation may provide options to override this default behavior for\n * repeated and message fields.\n *\n * In order to reset a field's value to the default, the field must\n * be in the mask and set to the default value in the provided resource.\n * Hence, in order to reset all fields of a resource, provide a default\n * instance of the resource and set all fields in the mask, or do\n * not provide a mask as described below.\n *\n * If a field mask is not present on update, the operation applies to\n * all fields (as if a field mask of all fields has been specified).\n * Note that in the presence of schema evolution, this may mean that\n * fields the client does not know and has therefore not filled into\n * the request will be reset to their default. If this is unwanted\n * behavior, a specific service may require a client to always specify\n * a field mask, producing an error if not.\n *\n * As with get operations, the location of the resource which\n * describes the updated values in the request message depends on the\n * operation kind. In any case, the effect of the field mask is\n * required to be honored by the API.\n *\n * ## Considerations for HTTP REST\n *\n * The HTTP kind of an update operation which uses a field mask must\n * be set to PATCH instead of PUT in order to satisfy HTTP semantics\n * (PUT must only be used for full updates).\n *\n * # JSON Encoding of Field Masks\n *\n * In JSON, a field mask is encoded as a single string where paths are\n * separated by a comma. Fields name in each path are converted\n * to/from lower-camel naming conventions.\n *\n * As an example, consider the following message declarations:\n *\n *     message Profile {\n *       User user = 1;\n *       Photo photo = 2;\n *     }\n *     message User {\n *       string display_name = 1;\n *       string address = 2;\n *     }\n *\n * In proto a field mask for `Profile` may look as such:\n *\n *     mask {\n *       paths: \"user.display_name\"\n *       paths: \"photo\"\n *     }\n *\n * In JSON, the same mask is represented as below:\n *\n *     {\n *       mask: \"user.displayName,photo\"\n *     }\n *\n * # Field Masks and Oneof Fields\n *\n * Field masks treat fields in oneofs just as regular fields. Consider the\n * following message:\n *\n *     message SampleMessage {\n *       oneof test_oneof {\n *         string name = 4;\n *         SubMessage sub_message = 9;\n *       }\n *     }\n *\n * The field mask can be:\n *\n *     mask {\n *       paths: \"name\"\n *     }\n *\n * Or:\n *\n *     mask {\n *       paths: \"sub_message\"\n *     }\n *\n * Note that oneof type names (\"test_oneof\" in this case) cannot be used in\n * paths.\n *\n * ## Field Mask Verification\n *\n * The implementation of any API method which has a FieldMask type field in the\n * request should verify the included field paths, and return an\n * `INVALID_ARGUMENT` error if any path is unmappable.\n *\n * @generated from protobuf message google.protobuf.FieldMask\n */\nexport interface FieldMask {\n    /**\n     * The set of field mask paths.\n     *\n     * @generated from protobuf field: repeated string paths = 1;\n     */\n    paths: string[];\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass FieldMask$Type extends MessageType<FieldMask> {\n    constructor() {\n        super(\"google.protobuf.FieldMask\", [\n            { no: 1, name: \"paths\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    /**\n     * Encode `FieldMask` to JSON object.\n     */\n    internalJsonWrite(message: FieldMask, options: JsonWriteOptions): JsonValue {\n        const invalidFieldMaskJsonRegex = /[A-Z]|(_([.0-9_]|$))/g;\n        return message.paths.map(p => {\n            if (invalidFieldMaskJsonRegex.test(p))\n                throw new Error(\"Unable to encode FieldMask to JSON. lowerCamelCase of path name \\\"\" + p + \"\\\" is irreversible.\");\n            return lowerCamelCase(p);\n        }).join(\",\");\n    }\n    /**\n     * Decode `FieldMask` from JSON object.\n     */\n    internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: FieldMask): FieldMask {\n        if (typeof json !== \"string\")\n            throw new Error(\"Unable to parse FieldMask from JSON \" + typeofJsonValue(json) + \". Expected string.\");\n        if (!target)\n            target = this.create();\n        if (json === \"\")\n            return target;\n        let camelToSnake = (str: string) => {\n            if (str.includes(\"_\"))\n                throw new Error(\"Unable to parse FieldMask from JSON. Path names must be lowerCamelCase.\");\n            let sc = str.replace(/[A-Z]/g, letter => \"_\" + letter.toLowerCase());\n            return sc;\n        };\n        target.paths = json.split(\",\").map(camelToSnake);\n        return target;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.FieldMask\n */\nexport const FieldMask = new FieldMask$Type();\n"],
  "mappings": "AAsCA,SAAS,uBAAuB;AAEhC,SAAS,sBAAsB;AAG/B,SAAS,mBAAmB;AAqN5B,MAAM,uBAAuB,YAAuB;AAAA,EAChD,cAAc;AACV,UAAM,6BAA6B;AAAA,MAC/B;AAAA,QAAE,IAAI;AAAA,QAAG,MAAM;AAAA,QAAS,MAAM;AAAA,QAAU,QAAQ;AAAA,QAA2B,GAAG;AAAA;AAAA,MAAwB;AAAA,IAC1G,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkB,SAAoB,SAAsC;AACxE,UAAM,4BAA4B;AAClC,WAAO,QAAQ,MAAM,IAAI,OAAK;AAC1B,UAAI,0BAA0B,KAAK,CAAC;AAChC,cAAM,IAAI,MAAM,sEAAuE,IAAI,oBAAqB;AACpH,aAAO,eAAe,CAAC;AAAA,IAC3B,CAAC,EAAE,KAAK,GAAG;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAIA,iBAAiB,MAAiB,SAA0B,QAA+B;AACvF,QAAI,OAAO,SAAS;AAChB,YAAM,IAAI,MAAM,yCAAyC,gBAAgB,IAAI,IAAI,oBAAoB;AACzG,QAAI,CAAC;AACD,eAAS,KAAK,OAAO;AACzB,QAAI,SAAS;AACT,aAAO;AACX,QAAI,eAAe,CAAC,QAAgB;AAChC,UAAI,IAAI,SAAS,GAAG;AAChB,cAAM,IAAI,MAAM,yEAAyE;AAC7F,UAAI,KAAK,IAAI,QAAQ,UAAU,YAAU,MAAM,OAAO,YAAY,CAAC;AACnE,aAAO;AAAA,IACX;AACA,WAAO,QAAQ,KAAK,MAAM,GAAG,EAAE,IAAI,YAAY;AAC/C,WAAO;AAAA,EACX;AACJ;AAIO,MAAM,YAAY,IAAI,eAAe;",
  "names": []
}
