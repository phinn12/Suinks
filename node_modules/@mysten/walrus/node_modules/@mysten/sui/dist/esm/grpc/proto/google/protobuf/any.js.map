{
  "version": 3,
  "sources": ["../../../../../../src/grpc/proto/google/protobuf/any.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// @generated by protobuf-ts 2.9.6 with parameter force_server_none,optimize_code_size,ts_nocheck\n// @generated from protobuf file \"google/protobuf/any.proto\" (package \"google.protobuf\", syntax proto3)\n// tslint:disable\n// @ts-nocheck\n//\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\nimport { isJsonObject } from \"@protobuf-ts/runtime\";\nimport { typeofJsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonValue } from \"@protobuf-ts/runtime\";\nimport { jsonWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { JsonReadOptions } from \"@protobuf-ts/runtime\";\nimport type { JsonWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IMessageType } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * `Any` contains an arbitrary serialized protocol buffer message along with a\n * URL that describes the type of the serialized message.\n *\n * Protobuf library provides support to pack/unpack Any values in the form\n * of utility functions or additional generated methods of the Any type.\n *\n * Example 1: Pack and unpack a message in C++.\n *\n *     Foo foo = ...;\n *     Any any;\n *     any.PackFrom(foo);\n *     ...\n *     if (any.UnpackTo(&foo)) {\n *       ...\n *     }\n *\n * Example 2: Pack and unpack a message in Java.\n *\n *     Foo foo = ...;\n *     Any any = Any.pack(foo);\n *     ...\n *     if (any.is(Foo.class)) {\n *       foo = any.unpack(Foo.class);\n *     }\n *     // or ...\n *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n *       foo = any.unpack(Foo.getDefaultInstance());\n *     }\n *\n *  Example 3: Pack and unpack a message in Python.\n *\n *     foo = Foo(...)\n *     any = Any()\n *     any.Pack(foo)\n *     ...\n *     if any.Is(Foo.DESCRIPTOR):\n *       any.Unpack(foo)\n *       ...\n *\n *  Example 4: Pack and unpack a message in Go\n *\n *      foo := &pb.Foo{...}\n *      any, err := anypb.New(foo)\n *      if err != nil {\n *        ...\n *      }\n *      ...\n *      foo := &pb.Foo{}\n *      if err := any.UnmarshalTo(foo); err != nil {\n *        ...\n *      }\n *\n * The pack methods provided by protobuf library will by default use\n * 'type.googleapis.com/full.type.name' as the type URL and the unpack\n * methods only use the fully qualified type name after the last '/'\n * in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n * name \"y.z\".\n *\n * JSON\n * ====\n * The JSON representation of an `Any` value uses the regular\n * representation of the deserialized, embedded message, with an\n * additional field `@type` which contains the type URL. Example:\n *\n *     package google.profile;\n *     message Person {\n *       string first_name = 1;\n *       string last_name = 2;\n *     }\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.profile.Person\",\n *       \"firstName\": <string>,\n *       \"lastName\": <string>\n *     }\n *\n * If the embedded message type is well-known and has a custom JSON\n * representation, that representation will be embedded adding a field\n * `value` which holds the custom JSON in addition to the `@type`\n * field. Example (for message [google.protobuf.Duration][]):\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n *       \"value\": \"1.212s\"\n *     }\n *\n *\n * @generated from protobuf message google.protobuf.Any\n */\nexport interface Any {\n    /**\n     * A URL/resource name that uniquely identifies the type of the serialized\n     * protocol buffer message. This string must contain at least\n     * one \"/\" character. The last segment of the URL's path must represent\n     * the fully qualified name of the type (as in\n     * `path/google.protobuf.Duration`). The name should be in a canonical form\n     * (e.g., leading \".\" is not accepted).\n     *\n     * In practice, teams usually precompile into the binary all types that they\n     * expect it to use in the context of Any. However, for URLs which use the\n     * scheme `http`, `https`, or no scheme, one can optionally set up a type\n     * server that maps type URLs to message definitions as follows:\n     *\n     * * If no scheme is provided, `https` is assumed.\n     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n     *   value in binary format, or produce an error.\n     * * Applications are allowed to cache lookup results based on the\n     *   URL, or have them precompiled into a binary to avoid any\n     *   lookup. Therefore, binary compatibility needs to be preserved\n     *   on changes to types. (Use versioned type names to manage\n     *   breaking changes.)\n     *\n     * Note: this functionality is not currently available in the official\n     * protobuf release, and it is not used for type URLs beginning with\n     * type.googleapis.com. As of May 2023, there are no widely used type server\n     * implementations and no plans to implement one.\n     *\n     * Schemes other than `http`, `https` (or the empty scheme) might be\n     * used with implementation specific semantics.\n     *\n     *\n     * @generated from protobuf field: string type_url = 1;\n     */\n    typeUrl: string;\n    /**\n     * Must be a valid serialized protocol buffer of the above specified type.\n     *\n     * @generated from protobuf field: bytes value = 2;\n     */\n    value: Uint8Array;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Any$Type extends MessageType<Any> {\n    constructor() {\n        super(\"google.protobuf.Any\", [\n            { no: 1, name: \"type_url\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"value\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    /**\n     * Pack the message into a new `Any`.\n     *\n     * Uses 'type.googleapis.com/full.type.name' as the type URL.\n     */\n    pack<T extends object>(message: T, type: IMessageType<T>): Any {\n        return {\n            typeUrl: this.typeNameToUrl(type.typeName), value: type.toBinary(message),\n        };\n    }\n    /**\n     * Unpack the message from the `Any`.\n     */\n    unpack<T extends object>(any: Any, type: IMessageType<T>, options?: Partial<BinaryReadOptions>): T {\n        if (!this.contains(any, type))\n            throw new Error(\"Cannot unpack google.protobuf.Any with typeUrl '\" + any.typeUrl + \"' as \" + type.typeName + \".\");\n        return type.fromBinary(any.value, options);\n    }\n    /**\n     * Does the given `Any` contain a packed message of the given type?\n     */\n    contains(any: Any, type: IMessageType<any> | string): boolean {\n        if (!any.typeUrl.length)\n            return false;\n        let wants = typeof type == \"string\" ? type : type.typeName;\n        let has = this.typeUrlToName(any.typeUrl);\n        return wants === has;\n    }\n    /**\n     * Convert the message to canonical JSON value.\n     *\n     * You have to provide the `typeRegistry` option so that the\n     * packed message can be converted to JSON.\n     *\n     * The `typeRegistry` option is also required to read\n     * `google.protobuf.Any` from JSON format.\n     */\n    internalJsonWrite(any: Any, options: JsonWriteOptions): JsonValue {\n        if (any.typeUrl === \"\")\n            return {};\n        let typeName = this.typeUrlToName(any.typeUrl);\n        let opt = jsonWriteOptions(options);\n        let type = opt.typeRegistry?.find(t => t.typeName === typeName);\n        if (!type)\n            throw new globalThis.Error(\"Unable to convert google.protobuf.Any with typeUrl '\" + any.typeUrl + \"' to JSON. The specified type \" + typeName + \" is not available in the type registry.\");\n        let value = type.fromBinary(any.value, { readUnknownField: false });\n        let json = type.internalJsonWrite(value, opt);\n        if (typeName.startsWith(\"google.protobuf.\") || !isJsonObject(json))\n            json = { value: json };\n        json[\"@type\"] = any.typeUrl;\n        return json;\n    }\n    internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: Any): Any {\n        if (!isJsonObject(json))\n            throw new globalThis.Error(\"Unable to parse google.protobuf.Any from JSON \" + typeofJsonValue(json) + \".\");\n        if (typeof json[\"@type\"] != \"string\" || json[\"@type\"] == \"\")\n            return this.create();\n        let typeName = this.typeUrlToName(json[\"@type\"]);\n        let type = options?.typeRegistry?.find(t => t.typeName == typeName);\n        if (!type)\n            throw new globalThis.Error(\"Unable to parse google.protobuf.Any from JSON. The specified type \" + typeName + \" is not available in the type registry.\");\n        let value;\n        if (typeName.startsWith(\"google.protobuf.\") && json.hasOwnProperty(\"value\"))\n            value = type.fromJson(json[\"value\"], options);\n        else {\n            let copy = Object.assign({}, json);\n            delete copy[\"@type\"];\n            value = type.fromJson(copy, options);\n        }\n        if (target === undefined)\n            target = this.create();\n        target.typeUrl = json[\"@type\"];\n        target.value = type.toBinary(value);\n        return target;\n    }\n    typeNameToUrl(name: string): string {\n        if (!name.length)\n            throw new Error(\"invalid type name: \" + name);\n        return \"type.googleapis.com/\" + name;\n    }\n    typeUrlToName(url: string): string {\n        if (!url.length)\n            throw new Error(\"invalid type url: \" + url);\n        let slash = url.lastIndexOf(\"/\");\n        let name = slash > 0 ? url.substring(slash + 1) : url;\n        if (!name.length)\n            throw new Error(\"invalid type url: \" + url);\n        return name;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Any\n */\nexport const Any = new Any$Type();\n"],
  "mappings": "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",
  "names": []
}
