{
  "version": 3,
  "sources": ["../../../../../../src/grpc/proto/google/protobuf/duration.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// @generated by protobuf-ts 2.9.6 with parameter force_server_none,optimize_code_size,ts_nocheck\n// @generated from protobuf file \"google/protobuf/duration.proto\" (package \"google.protobuf\", syntax proto3)\n// tslint:disable\n// @ts-nocheck\n//\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\nimport { typeofJsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonReadOptions } from \"@protobuf-ts/runtime\";\nimport type { JsonWriteOptions } from \"@protobuf-ts/runtime\";\nimport { PbLong } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * A Duration represents a signed, fixed-length span of time represented\n * as a count of seconds and fractions of seconds at nanosecond\n * resolution. It is independent of any calendar and concepts like \"day\"\n * or \"month\". It is related to Timestamp in that the difference between\n * two Timestamp values is a Duration and it can be added or subtracted\n * from a Timestamp. Range is approximately +-10,000 years.\n *\n * # Examples\n *\n * Example 1: Compute Duration from two Timestamps in pseudo code.\n *\n *     Timestamp start = ...;\n *     Timestamp end = ...;\n *     Duration duration = ...;\n *\n *     duration.seconds = end.seconds - start.seconds;\n *     duration.nanos = end.nanos - start.nanos;\n *\n *     if (duration.seconds < 0 && duration.nanos > 0) {\n *       duration.seconds += 1;\n *       duration.nanos -= 1000000000;\n *     } else if (duration.seconds > 0 && duration.nanos < 0) {\n *       duration.seconds -= 1;\n *       duration.nanos += 1000000000;\n *     }\n *\n * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\n *\n *     Timestamp start = ...;\n *     Duration duration = ...;\n *     Timestamp end = ...;\n *\n *     end.seconds = start.seconds + duration.seconds;\n *     end.nanos = start.nanos + duration.nanos;\n *\n *     if (end.nanos < 0) {\n *       end.seconds -= 1;\n *       end.nanos += 1000000000;\n *     } else if (end.nanos >= 1000000000) {\n *       end.seconds += 1;\n *       end.nanos -= 1000000000;\n *     }\n *\n * Example 3: Compute Duration from datetime.timedelta in Python.\n *\n *     td = datetime.timedelta(days=3, minutes=10)\n *     duration = Duration()\n *     duration.FromTimedelta(td)\n *\n * # JSON Mapping\n *\n * In JSON format, the Duration type is encoded as a string rather than an\n * object, where the string ends in the suffix \"s\" (indicating seconds) and\n * is preceded by the number of seconds, with nanoseconds expressed as\n * fractional seconds. For example, 3 seconds with 0 nanoseconds should be\n * encoded in JSON format as \"3s\", while 3 seconds and 1 nanosecond should\n * be expressed in JSON format as \"3.000000001s\", and 3 seconds and 1\n * microsecond should be expressed in JSON format as \"3.000001s\".\n *\n *\n * @generated from protobuf message google.protobuf.Duration\n */\nexport interface Duration {\n    /**\n     * Signed seconds of the span of time. Must be from -315,576,000,000\n     * to +315,576,000,000 inclusive. Note: these bounds are computed from:\n     * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years\n     *\n     * @generated from protobuf field: int64 seconds = 1;\n     */\n    seconds: bigint;\n    /**\n     * Signed fractions of a second at nanosecond resolution of the span\n     * of time. Durations less than one second are represented with a 0\n     * `seconds` field and a positive or negative `nanos` field. For durations\n     * of one second or more, a non-zero value for the `nanos` field must be\n     * of the same sign as the `seconds` field. Must be from -999,999,999\n     * to +999,999,999 inclusive.\n     *\n     * @generated from protobuf field: int32 nanos = 2;\n     */\n    nanos: number;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Duration$Type extends MessageType<Duration> {\n    constructor() {\n        super(\"google.protobuf.Duration\", [\n            { no: 1, name: \"seconds\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"nanos\", kind: \"scalar\", T: 5 /*ScalarType.INT32*/ }\n        ]);\n    }\n    /**\n     * Encode `Duration` to JSON string like \"3.000001s\".\n     */\n    internalJsonWrite(message: Duration, options: JsonWriteOptions): JsonValue {\n        let s = PbLong.from(message.seconds).toNumber();\n        if (s > 315576000000 || s < -315576000000)\n            throw new Error(\"Duration value out of range.\");\n        let text = message.seconds.toString();\n        if (s === 0 && message.nanos < 0)\n            text = \"-\" + text;\n        if (message.nanos !== 0) {\n            let nanosStr = Math.abs(message.nanos).toString();\n            nanosStr = \"0\".repeat(9 - nanosStr.length) + nanosStr;\n            if (nanosStr.substring(3) === \"000000\")\n                nanosStr = nanosStr.substring(0, 3);\n            else if (nanosStr.substring(6) === \"000\")\n                nanosStr = nanosStr.substring(0, 6);\n            text += \".\" + nanosStr;\n        }\n        return text + \"s\";\n    }\n    /**\n     * Decode `Duration` from JSON string like \"3.000001s\"\n     */\n    internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: Duration): Duration {\n        if (typeof json !== \"string\")\n            throw new Error(\"Unable to parse Duration from JSON \" + typeofJsonValue(json) + \". Expected string.\");\n        let match = json.match(/^(-?)([0-9]+)(?:\\.([0-9]+))?s/);\n        if (match === null)\n            throw new Error(\"Unable to parse Duration from JSON string. Invalid format.\");\n        if (!target)\n            target = this.create();\n        let [, sign, secs, nanos] = match;\n        let longSeconds = PbLong.from(sign + secs);\n        if (longSeconds.toNumber() > 315576000000 || longSeconds.toNumber() < -315576000000)\n            throw new Error(\"Unable to parse Duration from JSON string. Value out of range.\");\n        target.seconds = longSeconds.toBigInt();\n        if (typeof nanos == \"string\") {\n            let nanosStr = sign + nanos + \"0\".repeat(9 - nanos.length);\n            target.nanos = parseInt(nanosStr);\n        }\n        return target;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Duration\n */\nexport const Duration = new Duration$Type();\n"],
  "mappings": "AAsCA,SAAS,uBAAuB;AAIhC,SAAS,cAAc;AACvB,SAAS,mBAAmB;AAsF5B,MAAM,sBAAsB,YAAsB;AAAA,EAC9C,cAAc;AACV,UAAM,4BAA4B;AAAA,MAC9B;AAAA,QAAE,IAAI;AAAA,QAAG,MAAM;AAAA,QAAW,MAAM;AAAA,QAAU,GAAG;AAAA,QAAwB,GAAG;AAAA;AAAA,MAAsB;AAAA,MAC9F;AAAA,QAAE,IAAI;AAAA,QAAG,MAAM;AAAA,QAAS,MAAM;AAAA,QAAU,GAAG;AAAA;AAAA,MAAuB;AAAA,IACtE,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkB,SAAmB,SAAsC;AACvE,QAAI,IAAI,OAAO,KAAK,QAAQ,OAAO,EAAE,SAAS;AAC9C,QAAI,IAAI,YAAgB,IAAI;AACxB,YAAM,IAAI,MAAM,8BAA8B;AAClD,QAAI,OAAO,QAAQ,QAAQ,SAAS;AACpC,QAAI,MAAM,KAAK,QAAQ,QAAQ;AAC3B,aAAO,MAAM;AACjB,QAAI,QAAQ,UAAU,GAAG;AACrB,UAAI,WAAW,KAAK,IAAI,QAAQ,KAAK,EAAE,SAAS;AAChD,iBAAW,IAAI,OAAO,IAAI,SAAS,MAAM,IAAI;AAC7C,UAAI,SAAS,UAAU,CAAC,MAAM;AAC1B,mBAAW,SAAS,UAAU,GAAG,CAAC;AAAA,eAC7B,SAAS,UAAU,CAAC,MAAM;AAC/B,mBAAW,SAAS,UAAU,GAAG,CAAC;AACtC,cAAQ,MAAM;AAAA,IAClB;AACA,WAAO,OAAO;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAIA,iBAAiB,MAAiB,SAA0B,QAA6B;AACrF,QAAI,OAAO,SAAS;AAChB,YAAM,IAAI,MAAM,wCAAwC,gBAAgB,IAAI,IAAI,oBAAoB;AACxG,QAAI,QAAQ,KAAK,MAAM,+BAA+B;AACtD,QAAI,UAAU;AACV,YAAM,IAAI,MAAM,4DAA4D;AAChF,QAAI,CAAC;AACD,eAAS,KAAK,OAAO;AACzB,QAAI,CAAC,EAAE,MAAM,MAAM,KAAK,IAAI;AAC5B,QAAI,cAAc,OAAO,KAAK,OAAO,IAAI;AACzC,QAAI,YAAY,SAAS,IAAI,YAAgB,YAAY,SAAS,IAAI;AAClE,YAAM,IAAI,MAAM,gEAAgE;AACpF,WAAO,UAAU,YAAY,SAAS;AACtC,QAAI,OAAO,SAAS,UAAU;AAC1B,UAAI,WAAW,OAAO,QAAQ,IAAI,OAAO,IAAI,MAAM,MAAM;AACzD,aAAO,QAAQ,SAAS,QAAQ;AAAA,IACpC;AACA,WAAO;AAAA,EACX;AACJ;AAIO,MAAM,WAAW,IAAI,cAAc;",
  "names": []
}
