{
  "version": 3,
  "sources": ["../../../../../../src/grpc/proto/google/protobuf/timestamp.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// @generated by protobuf-ts 2.9.6 with parameter force_server_none,optimize_code_size,ts_nocheck\n// @generated from protobuf file \"google/protobuf/timestamp.proto\" (package \"google.protobuf\", syntax proto3)\n// tslint:disable\n// @ts-nocheck\n//\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\nimport { typeofJsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonReadOptions } from \"@protobuf-ts/runtime\";\nimport type { JsonWriteOptions } from \"@protobuf-ts/runtime\";\nimport { PbLong } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * A Timestamp represents a point in time independent of any time zone\n * or calendar, represented as seconds and fractions of seconds at\n * nanosecond resolution in UTC Epoch time. It is encoded using the\n * Proleptic Gregorian Calendar which extends the Gregorian calendar\n * backwards to year one. It is encoded assuming all minutes are 60\n * seconds long, i.e. leap seconds are \"smeared\" so that no leap second\n * table is needed for interpretation. Range is from\n * `0001-01-01T00:00:00Z` to `9999-12-31T23:59:59.999999999Z`.\n * Restricting to that range ensures that conversion to\n * and from RFC 3339 date strings is possible.\n * See [https://www.ietf.org/rfc/rfc3339.txt](https://www.ietf.org/rfc/rfc3339.txt).\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n * ```\n * Timestamp timestamp;\n * timestamp.set_seconds(time(NULL));\n * timestamp.set_nanos(0);\n * ```\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n * ```\n * struct timeval tv;\n * gettimeofday(&tv, NULL);\n *\n * Timestamp timestamp;\n * timestamp.set_seconds(tv.tv_sec);\n * timestamp.set_nanos(tv.tv_usec * 1000);\n * ```\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n * ```\n * FILETIME ft;\n * GetSystemTimeAsFileTime(&ft);\n * UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n * // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n * // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n * Timestamp timestamp;\n * timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n * timestamp.set_nanos((INT32) ((ticks % 10000000) * 100)); //\n * ```\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n * ```\n * long millis = System.currentTimeMillis();\n *\n * Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *     .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * ```\n *\n * Example 5: Compute Timestamp from current time in Python.\n *\n * ```\n * timestamp = Timestamp()\n * timestamp.GetCurrentTime()\n * ```\n *\n * # JSON Mapping\n *\n * In JSON format, the `Timestamp` type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is `{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z`\n * where `{year}` is always expressed using four digits while `{month}`, `{day}`,\n * `{hour}`, `{min}`, and `{sec}` are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (so up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required, though only UTC (as indicated by \"Z\") is presently supported.\n *\n * For example, `2017-01-15T01:30:15.01Z` encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, you can convert a `Date` object to this format using the\n * standard [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, you can convert a standard `datetime.datetime` object\n * to this format using [`strftime`](https://docs.python.org/2/library/time.html#time.strftime)\n * with the time format spec `%Y-%m-%dT%H:%M:%S.%fZ`. Likewise, in Java, you\n * can use the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime--)\n * to obtain a formatter capable of generating timestamps in this format.\n *\n *\n *\n * @generated from protobuf message google.protobuf.Timestamp\n */\nexport interface Timestamp {\n    /**\n     * Represents seconds of UTC time since Unix epoch\n     * `1970-01-01T00:00:00Z`. Must be from `0001-01-01T00:00:00Z` to\n     * `9999-12-31T23:59:59Z` inclusive.\n     *\n     * @generated from protobuf field: int64 seconds = 1;\n     */\n    seconds: bigint;\n    /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nano values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from protobuf field: int32 nanos = 2;\n     */\n    nanos: number;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Timestamp$Type extends MessageType<Timestamp> {\n    constructor() {\n        super(\"google.protobuf.Timestamp\", [\n            { no: 1, name: \"seconds\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"nanos\", kind: \"scalar\", T: 5 /*ScalarType.INT32*/ }\n        ]);\n    }\n    /**\n     * Creates a new `Timestamp` for the current time.\n     */\n    now(): Timestamp {\n        const msg = this.create();\n        const ms = Date.now();\n        msg.seconds = PbLong.from(Math.floor(ms / 1000)).toBigInt();\n        msg.nanos = (ms % 1000) * 1000000;\n        return msg;\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript Date.\n     */\n    toDate(message: Timestamp): Date {\n        return new Date(PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1000000));\n    }\n    /**\n     * Converts a JavaScript Date to a `Timestamp`.\n     */\n    fromDate(date: Date): Timestamp {\n        const msg = this.create();\n        const ms = date.getTime();\n        msg.seconds = PbLong.from(Math.floor(ms / 1000)).toBigInt();\n        msg.nanos = ((ms % 1000) + (ms < 0 && ms % 1000 !== 0 ? 1000 : 0)) * 1000000;\n        return msg;\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */\n    internalJsonWrite(message: Timestamp, options: JsonWriteOptions): JsonValue {\n        let ms = PbLong.from(message.seconds).toNumber() * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\"))\n            throw new Error(\"Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (message.nanos < 0)\n            throw new Error(\"Unable to encode invalid Timestamp to JSON. Nanos must not be negative.\");\n        let z = \"Z\";\n        if (message.nanos > 0) {\n            let nanosStr = (message.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\")\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            else if (nanosStr.substring(6) === \"000\")\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            else\n                z = \".\" + nanosStr + \"Z\";\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */\n    internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: Timestamp): Timestamp {\n        if (typeof json !== \"string\")\n            throw new Error(\"Unable to parse Timestamp from JSON \" + typeofJsonValue(json) + \".\");\n        let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches)\n            throw new Error(\"Unable to parse Timestamp from JSON. Invalid format.\");\n        let ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms))\n            throw new Error(\"Unable to parse Timestamp from JSON. Invalid value.\");\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\"))\n            throw new globalThis.Error(\"Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (!target)\n            target = this.create();\n        target.seconds = PbLong.from(ms / 1000).toBigInt();\n        target.nanos = 0;\n        if (matches[7])\n            target.nanos = (parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000);\n        return target;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Timestamp\n */\nexport const Timestamp = new Timestamp$Type();\n"],
  "mappings": "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",
  "names": []
}
