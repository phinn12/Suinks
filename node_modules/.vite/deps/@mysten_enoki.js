import {
  Experimental_BaseClient,
  Experimental_CoreClient,
  ObjectError,
  parseTransactionBcs,
  parseTransactionEffectsBcs
} from "./chunk-AU57QNCC.js";
import "./chunk-OW3RTILI.js";
import {
  PasskeyAuthenticator,
  SUI_ADDRESS_LENGTH,
  Transaction,
  bcs,
  deriveDynamicFieldID,
  fromBase64,
  fromBase642,
  fromHex,
  normalizeStructTag,
  normalizeSuiAddress,
  suiBcs,
  toBase64,
  toBase642,
  toHex
} from "./chunk-N5GBBSG5.js";
import {
  Field,
  ReadonlyWalletAccount,
  StandardConnect,
  StandardDisconnect,
  StandardEvents,
  WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED,
  WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND,
  WalletStandardError,
  _normFnElement,
  aInRange,
  bytesToNumberBE,
  createCurve,
  createHasher as createHasher2,
  ed25519,
  ensureBytes,
  getWallets,
  hmac,
  inRange,
  isogenyMap,
  mapHashToField,
  mapToCurveSimpleSWU,
  mitt_default,
  mnemonicToSeedSync,
  mod,
  numberToBytesBE,
  pow2,
  print,
  require_poseidon_lite,
  safeCaptureStackTrace,
  secp256r1,
  sha256,
  sha2562,
  sha512
} from "./chunk-SJ262J7Y.js";
import {
  Chi,
  HashMD,
  Maj,
  bech32,
  blake2b,
  bytesToHex,
  clean,
  concatBytes,
  createBase58check,
  createHasher,
  hexToBytes,
  randomBytes,
  rotl,
  utf8ToBytes
} from "./chunk-JCWM4AKD.js";
import {
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/@mysten/enoki/dist/esm/EnokiClient/index.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _version;
var _apiUrl;
var _apiKey;
var _EnokiClient_instances;
var fetch_fn;
var DEFAULT_API_URL = "https://api.enoki.mystenlabs.com";
var ZKLOGIN_HEADER = "zklogin-jwt";
var EnokiClientError = class extends Error {
  constructor(status, response) {
    var _a;
    let errors;
    try {
      const parsedResponse = JSON.parse(response);
      errors = parsedResponse.errors;
    } catch {
    }
    const cause = (errors == null ? void 0 : errors[0]) ? new Error(errors[0].message) : void 0;
    super(`Request to Enoki API failed (status: ${status})`, {
      cause
    });
    this.errors = [];
    this.errors = errors ?? [];
    this.name = "EnokiClientError";
    this.status = status;
    this.code = ((_a = errors == null ? void 0 : errors[0]) == null ? void 0 : _a.code) ?? "unknown_error";
  }
};
var EnokiClient = class {
  constructor(config) {
    __privateAdd(this, _EnokiClient_instances);
    __privateAdd(this, _version);
    __privateAdd(this, _apiUrl);
    __privateAdd(this, _apiKey);
    __privateSet(this, _version, "v1");
    __privateSet(this, _apiUrl, config.apiUrl ?? DEFAULT_API_URL);
    __privateSet(this, _apiKey, config.apiKey);
  }
  getApp(_input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "app", {
      method: "GET"
    });
  }
  getZkLogin(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin", {
      method: "GET",
      headers: {
        [ZKLOGIN_HEADER]: input.jwt
      }
    });
  }
  getZkLoginAddresses(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin/addresses", {
      method: "GET",
      headers: {
        [ZKLOGIN_HEADER]: input.jwt
      }
    });
  }
  createZkLoginNonce(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin/nonce", {
      method: "POST",
      body: JSON.stringify({
        network: input.network,
        ephemeralPublicKey: input.ephemeralPublicKey.toSuiPublicKey(),
        additionalEpochs: input.additionalEpochs
      })
    });
  }
  createZkLoginZkp(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin/zkp", {
      method: "POST",
      headers: {
        [ZKLOGIN_HEADER]: input.jwt
      },
      body: JSON.stringify({
        network: input.network,
        ephemeralPublicKey: input.ephemeralPublicKey.toSuiPublicKey(),
        maxEpoch: input.maxEpoch,
        randomness: input.randomness
      })
    });
  }
  createSponsoredTransaction(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "transaction-blocks/sponsor", {
      method: "POST",
      headers: input.jwt ? {
        [ZKLOGIN_HEADER]: input.jwt
      } : {},
      body: JSON.stringify({
        sender: input.sender,
        network: input.network,
        transactionBlockKindBytes: input.transactionKindBytes,
        allowedAddresses: input.allowedAddresses,
        allowedMoveCallTargets: input.allowedMoveCallTargets
      })
    });
  }
  executeSponsoredTransaction(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, `transaction-blocks/sponsor/${input.digest}`, {
      method: "POST",
      body: JSON.stringify({
        signature: input.signature
      })
    });
  }
  getSubnames(input) {
    const query = new URLSearchParams();
    if (input.address) {
      query.set("address", input.address);
    }
    if (input.network) {
      query.set("network", input.network);
    }
    if (input.domain) {
      query.set("domain", input.domain);
    }
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "subnames" + (query.size > 0 ? `?${query.toString()}` : ""), {
      method: "GET"
    });
  }
  createSubname(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "subnames", {
      method: "POST",
      headers: input.jwt ? {
        [ZKLOGIN_HEADER]: input.jwt
      } : {},
      body: JSON.stringify({
        network: input.network,
        domain: input.domain,
        subname: input.subname,
        targetAddress: input.targetAddress
      })
    });
  }
  deleteSubname(input) {
    __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "subnames", {
      method: "DELETE",
      body: JSON.stringify({
        network: input.network,
        domain: input.domain,
        subname: input.subname
      })
    });
  }
};
_version = /* @__PURE__ */ new WeakMap();
_apiUrl = /* @__PURE__ */ new WeakMap();
_apiKey = /* @__PURE__ */ new WeakMap();
_EnokiClient_instances = /* @__PURE__ */ new WeakSet();
fetch_fn = async function(path, init) {
  const res = await fetch(`${__privateGet(this, _apiUrl)}/${__privateGet(this, _version)}/${path}`, {
    ...init,
    headers: {
      ...init.headers,
      Authorization: `Bearer ${__privateGet(this, _apiKey)}`,
      "Content-Type": "application/json",
      "Request-Id": crypto.randomUUID()
    }
  });
  if (!res.ok) {
    throw new EnokiClientError(res.status, await res.text());
  }
  const { data } = await res.json();
  return data;
};

// node_modules/@mysten/sui/dist/esm/cryptography/intent.js
function messageWithIntent(scope, message) {
  return suiBcs.IntentMessage(suiBcs.bytes(message.length)).serialize({
    intent: {
      scope: { [scope]: true },
      version: { V0: true },
      appId: { Sui: true }
    },
    value: message
  }).toBytes();
}

// node_modules/@mysten/sui/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5,
  Passkey: 6
};
var SIGNATURE_SCHEME_TO_SIZE = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33,
  Passkey: 33
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin",
  6: "Passkey"
};

// node_modules/@mysten/sui/dist/esm/cryptography/publickey.js
function bytesEqual(a, b) {
  if (a === b) return true;
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
var PublicKey = class {
  /**
   * Checks if two public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return toBase64(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const bytes = this.toSuiBytes();
    return toBase64(bytes);
  }
  verifyWithIntent(bytes, signature, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    return this.verify(digest, signature);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    return this.verifyWithIntent(
      suiBcs.byteVector().serialize(message).toBytes(),
      signature,
      "PersonalMessage"
    );
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    return this.verifyWithIntent(transaction, signature, "TransactionData");
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return this.toSuiAddress() === address;
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const rawBytes = this.toRawBytes();
    const suiBytes = new Uint8Array(rawBytes.length + 1);
    suiBytes.set([this.flag()]);
    suiBytes.set(rawBytes, 1);
    return suiBytes;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return normalizeSuiAddress(
      bytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
    );
  }
};
function parseSerializedKeypairSignature(serializedSignature) {
  const bytes = fromBase64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
      const signature = bytes.slice(1, bytes.length - size);
      const publicKey = bytes.slice(1 + signature.length);
      return {
        serializedSignature,
        signatureScheme,
        signature,
        publicKey,
        bytes
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/@mysten/sui/dist/esm/keypairs/passkey/publickey.js
var PASSKEY_PUBLIC_KEY_SIZE = 33;
var PASSKEY_SIGNATURE_SIZE = 64;
var SECP256R1_SPKI_HEADER = new Uint8Array([
  48,
  89,
  // SEQUENCE, length 89
  48,
  19,
  // SEQUENCE, length 19
  6,
  7,
  // OID, length 7
  42,
  134,
  72,
  206,
  61,
  2,
  1,
  // OID: 1.2.840.10045.2.1 (ecPublicKey)
  6,
  8,
  // OID, length 8
  42,
  134,
  72,
  206,
  61,
  3,
  1,
  7,
  // OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)
  3,
  66,
  // BIT STRING, length 66
  0
  // no unused bits
]);
var PasskeyPublicKey = class extends PublicKey {
  /**
   * Create a new PasskeyPublicKey object
   * @param value passkey public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two passkey public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Passkey"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    const parsed = parseSerializedPasskeySignature(signature);
    const clientDataJSON = JSON.parse(parsed.clientDataJson);
    if (clientDataJSON.type !== "webauthn.get") {
      return false;
    }
    const parsedChallenge = fromBase64(
      clientDataJSON.challenge.replace(/-/g, "+").replace(/_/g, "/")
    );
    if (!bytesEqual(message, parsedChallenge)) {
      return false;
    }
    const pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);
    if (!bytesEqual(this.toRawBytes(), pk)) {
      return false;
    }
    const payload = new Uint8Array([...parsed.authenticatorData, ...sha2562(parsed.clientDataJson)]);
    const sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);
    return secp256r1.verify(sig, sha2562(payload), pk);
  }
};
PasskeyPublicKey.SIZE = PASSKEY_PUBLIC_KEY_SIZE;
function parseSerializedPasskeySignature(signature) {
  const bytes = typeof signature === "string" ? fromBase64(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {
    throw new Error("Invalid signature scheme");
  }
  const dec = PasskeyAuthenticator.parse(bytes.slice(1));
  return {
    signatureScheme: "Passkey",
    serializedSignature: toBase64(bytes),
    signature: bytes,
    authenticatorData: dec.authenticatorData,
    clientDataJson: dec.clientDataJson,
    userSignature: new Uint8Array(dec.userSignature),
    publicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE))
  };
}

// node_modules/@mysten/sui/dist/esm/graphql/generated/queries.js
var AddressTransactionBlockRelationship = ((AddressTransactionBlockRelationship2) => {
  AddressTransactionBlockRelationship2["Affected"] = "AFFECTED";
  AddressTransactionBlockRelationship2["Sent"] = "SENT";
  return AddressTransactionBlockRelationship2;
})(AddressTransactionBlockRelationship || {});
var DomainFormat = ((DomainFormat2) => {
  DomainFormat2["At"] = "AT";
  DomainFormat2["Dot"] = "DOT";
  return DomainFormat2;
})(DomainFormat || {});
var ExecutionStatus = ((ExecutionStatus2) => {
  ExecutionStatus2["Failure"] = "FAILURE";
  ExecutionStatus2["Success"] = "SUCCESS";
  return ExecutionStatus2;
})(ExecutionStatus || {});
var Feature = ((Feature2) => {
  Feature2["Analytics"] = "ANALYTICS";
  Feature2["Coins"] = "COINS";
  Feature2["DynamicFields"] = "DYNAMIC_FIELDS";
  Feature2["MoveRegistry"] = "MOVE_REGISTRY";
  Feature2["NameService"] = "NAME_SERVICE";
  Feature2["Subscriptions"] = "SUBSCRIPTIONS";
  Feature2["SystemState"] = "SYSTEM_STATE";
  return Feature2;
})(Feature || {});
var MoveAbility = ((MoveAbility2) => {
  MoveAbility2["Copy"] = "COPY";
  MoveAbility2["Drop"] = "DROP";
  MoveAbility2["Key"] = "KEY";
  MoveAbility2["Store"] = "STORE";
  return MoveAbility2;
})(MoveAbility || {});
var MoveVisibility = ((MoveVisibility2) => {
  MoveVisibility2["Friend"] = "FRIEND";
  MoveVisibility2["Private"] = "PRIVATE";
  MoveVisibility2["Public"] = "PUBLIC";
  return MoveVisibility2;
})(MoveVisibility || {});
var ObjectKind = ((ObjectKind2) => {
  ObjectKind2["Indexed"] = "INDEXED";
  ObjectKind2["NotIndexed"] = "NOT_INDEXED";
  return ObjectKind2;
})(ObjectKind || {});
var StakeStatus = ((StakeStatus2) => {
  StakeStatus2["Active"] = "ACTIVE";
  StakeStatus2["Pending"] = "PENDING";
  StakeStatus2["Unstaked"] = "UNSTAKED";
  return StakeStatus2;
})(StakeStatus || {});
var TransactionBlockKindInput = ((TransactionBlockKindInput2) => {
  TransactionBlockKindInput2["ProgrammableTx"] = "PROGRAMMABLE_TX";
  TransactionBlockKindInput2["SystemTx"] = "SYSTEM_TX";
  return TransactionBlockKindInput2;
})(TransactionBlockKindInput || {});
var ZkLoginIntentScope = ((ZkLoginIntentScope2) => {
  ZkLoginIntentScope2["PersonalMessage"] = "PERSONAL_MESSAGE";
  ZkLoginIntentScope2["TransactionData"] = "TRANSACTION_DATA";
  return ZkLoginIntentScope2;
})(ZkLoginIntentScope || {});
var TypedDocumentString = class extends String {
  constructor(value, __meta__) {
    super(value);
    this.value = value;
    this.__meta__ = __meta__;
  }
  toString() {
    return this.value;
  }
};
var Object_Owner_FieldsFragmentDoc = new TypedDocumentString(`
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}
    `, { "fragmentName": "OBJECT_OWNER_FIELDS" });
var Object_FieldsFragmentDoc = new TypedDocumentString(`
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`, { "fragmentName": "OBJECT_FIELDS" });
var Move_Object_FieldsFragmentDoc = new TypedDocumentString(`
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`, { "fragmentName": "MOVE_OBJECT_FIELDS" });
var Transaction_FieldsFragmentDoc = new TypedDocumentString(`
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}
    `, { "fragmentName": "TRANSACTION_FIELDS" });
var GetAllBalancesDocument = new TypedDocumentString(`
    query getAllBalances($owner: SuiAddress!, $limit: Int, $cursor: String) {
  address(address: $owner) {
    balances(first: $limit, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        coinType {
          repr
        }
        coinObjectCount
        totalBalance
      }
    }
  }
}
    `);
var GetBalanceDocument = new TypedDocumentString(`
    query getBalance($owner: SuiAddress!, $type: String = "0x2::sui::SUI") {
  address(address: $owner) {
    balance(type: $type) {
      coinType {
        repr
      }
      coinObjectCount
      totalBalance
    }
  }
}
    `);
var GetCoinsDocument = new TypedDocumentString(`
    query getCoins($owner: SuiAddress!, $first: Int, $cursor: String, $type: String = "0x2::sui::SUI") {
  address(address: $owner) {
    address
    coins(first: $first, after: $cursor, type: $type) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        coinBalance
        owner {
          ...OBJECT_OWNER_FIELDS
        }
        contents {
          bcs
          type {
            repr
          }
        }
        address
        version
        digest
        previousTransactionBlock {
          digest
        }
      }
    }
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`);
var GetDynamicFieldsDocument = new TypedDocumentString(`
    query getDynamicFields($parentId: SuiAddress!, $first: Int, $cursor: String) {
  owner(address: $parentId) {
    dynamicFields(first: $first, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        name {
          bcs
          type {
            repr
          }
        }
        value {
          __typename
          ... on MoveValue {
            type {
              repr
            }
          }
          ... on MoveObject {
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
  }
}
    `);
var GetMoveFunctionDocument = new TypedDocumentString(`
    query getMoveFunction($package: SuiAddress!, $module: String!, $function: String!) {
  package(address: $package) {
    module(name: $module) {
      function(name: $function) {
        name
        visibility
        isEntry
        typeParameters {
          constraints
        }
        parameters {
          signature
        }
        return {
          signature
        }
      }
    }
  }
}
    `);
var GetReferenceGasPriceDocument = new TypedDocumentString(`
    query getReferenceGasPrice {
  epoch {
    referenceGasPrice
  }
}
    `);
var ResolveNameServiceNamesDocument = new TypedDocumentString(`
    query resolveNameServiceNames($address: SuiAddress!, $limit: Int, $cursor: String) {
  address(address: $address) {
    suinsRegistrations(first: $limit, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        domain
      }
    }
  }
}
    `);
var GetOwnedObjectsDocument = new TypedDocumentString(`
    query getOwnedObjects($owner: SuiAddress!, $limit: Int, $cursor: String, $filter: ObjectFilter) {
  address(address: $owner) {
    objects(first: $limit, after: $cursor, filter: $filter) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        ...MOVE_OBJECT_FIELDS
      }
    }
  }
}
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`);
var MultiGetObjectsDocument = new TypedDocumentString(`
    query multiGetObjects($objectIds: [SuiAddress!]!, $limit: Int, $cursor: String) {
  objects(first: $limit, after: $cursor, filter: {objectIds: $objectIds}) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      ...OBJECT_FIELDS
    }
  }
}
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`);
var DryRunTransactionBlockDocument = new TypedDocumentString(`
    query dryRunTransactionBlock($txBytes: String!) {
  dryRunTransactionBlock(txBytes: $txBytes) {
    error
    transaction {
      ...TRANSACTION_FIELDS
    }
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`);
var ExecuteTransactionBlockDocument = new TypedDocumentString(`
    mutation executeTransactionBlock($txBytes: String!, $signatures: [String!]!) {
  executeTransactionBlock(txBytes: $txBytes, signatures: $signatures) {
    errors
    effects {
      transactionBlock {
        ...TRANSACTION_FIELDS
      }
    }
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`);
var GetTransactionBlockDocument = new TypedDocumentString(`
    query getTransactionBlock($digest: String!) {
  transactionBlock(digest: $digest) {
    ...TRANSACTION_FIELDS
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`);
var VerifyZkLoginSignatureDocument = new TypedDocumentString(`
    query verifyZkLoginSignature($bytes: Base64!, $signature: Base64!, $intentScope: ZkLoginIntentScope!, $author: SuiAddress!) {
  verifyZkloginSignature(
    bytes: $bytes
    signature: $signature
    intentScope: $intentScope
    author: $author
  ) {
    success
    errors
  }
}
    `);

// node_modules/@mysten/sui/dist/esm/graphql/core.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var _graphqlClient;
var _GraphQLCoreClient_instances;
var graphqlQuery_fn;
var GraphQLCoreClient = class extends Experimental_CoreClient {
  constructor({
    graphqlClient,
    mvr
  }) {
    super({ network: graphqlClient.network, base: graphqlClient, mvr });
    __privateAdd2(this, _GraphQLCoreClient_instances);
    __privateAdd2(this, _graphqlClient);
    __privateSet2(this, _graphqlClient, graphqlClient);
  }
  async getObjects(options) {
    const objects = [];
    let hasNextPage = true;
    let cursor = null;
    while (hasNextPage) {
      const objectsPage = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
        query: MultiGetObjectsDocument,
        variables: {
          objectIds: options.objectIds,
          cursor
        }
      }, (result) => result.objects);
      objects.push(...objectsPage.nodes);
      hasNextPage = objectsPage.pageInfo.hasNextPage;
      cursor = objectsPage.pageInfo.endCursor ?? null;
    }
    return {
      objects: options.objectIds.map((id) => normalizeSuiAddress(id)).map(
        (id) => objects.find((obj) => obj.address === id) ?? new ObjectError("notFound", `Object ${id} not found`)
      ).map((obj) => {
        var _a, _b, _c, _d, _e, _f;
        if (obj instanceof ObjectError) {
          return obj;
        }
        return {
          id: obj.address,
          version: obj.version.toString(),
          digest: obj.digest,
          owner: mapOwner(obj.owner),
          type: (_c = (_b = (_a = obj.asMoveObject) == null ? void 0 : _a.contents) == null ? void 0 : _b.type) == null ? void 0 : _c.repr,
          content: Promise.resolve(
            ((_e = (_d = obj.asMoveObject) == null ? void 0 : _d.contents) == null ? void 0 : _e.bcs) ? fromBase642(obj.asMoveObject.contents.bcs) : new Uint8Array()
          ),
          previousTransaction: ((_f = obj.previousTransactionBlock) == null ? void 0 : _f.digest) ?? null
        };
      })
    };
  }
  async getOwnedObjects(options) {
    const objects = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetOwnedObjectsDocument,
      variables: {
        owner: options.address,
        limit: options.limit,
        cursor: options.cursor,
        filter: options.type ? { type: (await this.mvr.resolveType({ type: options.type })).type } : void 0
      }
    }, (result) => {
      var _a;
      return (_a = result.address) == null ? void 0 : _a.objects;
    });
    return {
      objects: objects.nodes.map((obj) => {
        var _a, _b, _c, _d;
        return {
          id: obj.address,
          version: obj.version.toString(),
          digest: obj.digest,
          owner: mapOwner(obj.owner),
          type: (_b = (_a = obj.contents) == null ? void 0 : _a.type) == null ? void 0 : _b.repr,
          content: Promise.resolve(
            ((_c = obj.contents) == null ? void 0 : _c.bcs) ? fromBase642(obj.contents.bcs) : new Uint8Array()
          ),
          previousTransaction: ((_d = obj.previousTransactionBlock) == null ? void 0 : _d.digest) ?? null
        };
      }),
      hasNextPage: objects.pageInfo.hasNextPage,
      cursor: objects.pageInfo.endCursor ?? null
    };
  }
  async getCoins(options) {
    const coins = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetCoinsDocument,
      variables: {
        owner: options.address,
        cursor: options.cursor,
        first: options.limit,
        type: (await this.mvr.resolveType({ type: options.coinType })).type
      }
    }, (result) => {
      var _a;
      return (_a = result.address) == null ? void 0 : _a.coins;
    });
    return {
      cursor: coins.pageInfo.endCursor ?? null,
      hasNextPage: coins.pageInfo.hasNextPage,
      objects: coins.nodes.map((coin) => {
        var _a, _b, _c, _d;
        return {
          id: coin.address,
          version: coin.version.toString(),
          digest: coin.digest,
          owner: mapOwner(coin.owner),
          type: (_b = (_a = coin.contents) == null ? void 0 : _a.type) == null ? void 0 : _b.repr,
          balance: coin.coinBalance,
          content: Promise.resolve(
            ((_c = coin.contents) == null ? void 0 : _c.bcs) ? fromBase642(coin.contents.bcs) : new Uint8Array()
          ),
          previousTransaction: ((_d = coin.previousTransactionBlock) == null ? void 0 : _d.digest) ?? null
        };
      })
    };
  }
  async getBalance(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetBalanceDocument,
      variables: {
        owner: options.address,
        type: (await this.mvr.resolveType({ type: options.coinType })).type
      }
    }, (result2) => {
      var _a;
      return (_a = result2.address) == null ? void 0 : _a.balance;
    });
    return {
      balance: {
        coinType: result.coinType.repr,
        balance: result.totalBalance
      }
    };
  }
  async getAllBalances(options) {
    const balances = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetAllBalancesDocument,
      variables: { owner: options.address }
    }, (result) => {
      var _a;
      return (_a = result.address) == null ? void 0 : _a.balances;
    });
    return {
      cursor: balances.pageInfo.endCursor ?? null,
      hasNextPage: balances.pageInfo.hasNextPage,
      balances: balances.nodes.map((balance) => ({
        coinType: balance.coinType.repr,
        balance: balance.totalBalance
      }))
    };
  }
  async getTransaction(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetTransactionBlockDocument,
      variables: { digest: options.digest }
    }, (result2) => result2.transactionBlock);
    return {
      transaction: parseTransaction(result)
    };
  }
  async executeTransaction(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: ExecuteTransactionBlockDocument,
      variables: { txBytes: toBase642(options.transaction), signatures: options.signatures }
    }, (result2) => result2.executeTransactionBlock);
    if (result.errors) {
      if (result.errors.length === 1) {
        throw new Error(result.errors[0]);
      }
      throw new AggregateError(result.errors.map((error) => new Error(error)));
    }
    return {
      transaction: parseTransaction(result.effects.transactionBlock)
    };
  }
  async dryRunTransaction(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: DryRunTransactionBlockDocument,
      variables: { txBytes: toBase642(options.transaction) }
    }, (result2) => result2.dryRunTransactionBlock);
    if (result.error) {
      throw new Error(result.error);
    }
    return {
      transaction: parseTransaction(result.transaction)
    };
  }
  async getReferenceGasPrice() {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetReferenceGasPriceDocument
    }, (result2) => {
      var _a;
      return (_a = result2.epoch) == null ? void 0 : _a.referenceGasPrice;
    });
    return {
      referenceGasPrice: result
    };
  }
  async getDynamicFields(options) {
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetDynamicFieldsDocument,
      variables: { parentId: options.parentId }
    }, (result2) => {
      var _a;
      return (_a = result2.owner) == null ? void 0 : _a.dynamicFields;
    });
    return {
      dynamicFields: result.nodes.map((dynamicField) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        const valueType = ((_a = dynamicField.value) == null ? void 0 : _a.__typename) === "MoveObject" ? (_c = (_b = dynamicField.value.contents) == null ? void 0 : _b.type) == null ? void 0 : _c.repr : (_d = dynamicField.value) == null ? void 0 : _d.type.repr;
        return {
          id: deriveDynamicFieldID(
            options.parentId,
            (_e = dynamicField.name) == null ? void 0 : _e.type.repr,
            fromBase642((_f = dynamicField.name) == null ? void 0 : _f.bcs)
          ),
          type: normalizeStructTag(
            ((_g = dynamicField.value) == null ? void 0 : _g.__typename) === "MoveObject" ? `0x2::dynamic_field::Field<0x2::dynamic_object_field::Wrapper<${(_h = dynamicField.name) == null ? void 0 : _h.type.repr}>,0x2::object::ID>` : `0x2::dynamic_field::Field<${(_i = dynamicField.name) == null ? void 0 : _i.type.repr},${valueType}>`
          ),
          name: {
            type: (_j = dynamicField.name) == null ? void 0 : _j.type.repr,
            bcs: fromBase642((_k = dynamicField.name) == null ? void 0 : _k.bcs)
          },
          valueType
        };
      }),
      cursor: result.pageInfo.endCursor ?? null,
      hasNextPage: result.pageInfo.hasNextPage
    };
  }
  async verifyZkLoginSignature(options) {
    const intentScope = options.intentScope === "TransactionData" ? ZkLoginIntentScope.TransactionData : ZkLoginIntentScope.PersonalMessage;
    const result = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: VerifyZkLoginSignatureDocument,
      variables: {
        bytes: options.bytes,
        signature: options.signature,
        intentScope,
        author: options.author
      }
    }, (result2) => result2.verifyZkloginSignature);
    return {
      success: result.success,
      errors: result.errors
    };
  }
  async resolveNameServiceNames(options) {
    const suinsRegistrations = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: ResolveNameServiceNamesDocument,
      signal: options.signal,
      variables: {
        address: options.address,
        cursor: options.cursor,
        limit: options.limit
      }
    }, (result) => {
      var _a;
      return (_a = result.address) == null ? void 0 : _a.suinsRegistrations;
    });
    return {
      hasNextPage: suinsRegistrations.pageInfo.hasNextPage,
      nextCursor: suinsRegistrations.pageInfo.endCursor ?? null,
      data: suinsRegistrations.nodes.map((node) => node.domain) ?? []
    };
  }
  async getMoveFunction(options) {
    var _a, _b, _c;
    const moveFunction = await __privateMethod2(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetMoveFunctionDocument,
      variables: {
        package: (await this.mvr.resolvePackage({ package: options.packageId })).package,
        module: options.moduleName,
        function: options.name
      }
    }, (result) => {
      var _a2, _b2;
      return (_b2 = (_a2 = result.package) == null ? void 0 : _a2.module) == null ? void 0 : _b2.function;
    });
    let visibility = "unknown";
    switch (moveFunction.visibility) {
      case "PUBLIC":
        visibility = "public";
        break;
      case "PRIVATE":
        visibility = "private";
        break;
      case "FRIEND":
        visibility = "friend";
        break;
    }
    return {
      function: {
        packageId: normalizeSuiAddress(options.packageId),
        moduleName: options.moduleName,
        name: moveFunction.name,
        visibility,
        isEntry: moveFunction.isEntry ?? false,
        typeParameters: ((_a = moveFunction.typeParameters) == null ? void 0 : _a.map(({ constraints }) => ({
          isPhantom: false,
          constraints: constraints.map((constraint) => {
            switch (constraint) {
              case "COPY":
                return "copy";
              case "DROP":
                return "drop";
              case "STORE":
                return "store";
              case "KEY":
                return "key";
              default:
                return "unknown";
            }
          }) ?? []
        }))) ?? [],
        parameters: ((_b = moveFunction.parameters) == null ? void 0 : _b.map((param) => parseNormalizedSuiMoveType(param.signature))) ?? [],
        returns: ((_c = moveFunction.return) == null ? void 0 : _c.map(({ signature }) => parseNormalizedSuiMoveType(signature))) ?? []
      }
    };
  }
  resolveTransactionPlugin() {
    throw new Error("GraphQL client does not support transaction resolution yet");
  }
};
_graphqlClient = /* @__PURE__ */ new WeakMap();
_GraphQLCoreClient_instances = /* @__PURE__ */ new WeakSet();
graphqlQuery_fn = async function(options, getData) {
  const { data, errors } = await __privateGet2(this, _graphqlClient).query(options);
  handleGraphQLErrors(errors);
  const extractedData = data && (getData ? getData(data) : data);
  if (extractedData == null) {
    throw new Error("Missing response data");
  }
  return extractedData;
};
function handleGraphQLErrors(errors) {
  if (!errors || errors.length === 0) return;
  const errorInstances = errors.map((error) => new GraphQLResponseError(error));
  if (errorInstances.length === 1) {
    throw errorInstances[0];
  }
  throw new AggregateError(errorInstances);
}
var GraphQLResponseError = class extends Error {
  constructor(error) {
    super(error.message);
    this.locations = error.locations;
  }
};
function mapOwner(owner) {
  var _a, _b, _c, _d;
  switch (owner.__typename) {
    case "AddressOwner":
      return { $kind: "AddressOwner", AddressOwner: (_b = (_a = owner.owner) == null ? void 0 : _a.asAddress) == null ? void 0 : _b.address };
    case "ConsensusAddressOwner":
      return {
        $kind: "ConsensusAddressOwner",
        ConsensusAddressOwner: {
          owner: (_c = owner.owner) == null ? void 0 : _c.address,
          startVersion: String(owner.startVersion)
        }
      };
    case "Immutable":
      return { $kind: "Immutable", Immutable: true };
    case "Parent":
      return { $kind: "ObjectOwner", ObjectOwner: (_d = owner.parent) == null ? void 0 : _d.address };
    case "Shared":
      return {
        $kind: "Shared",
        Shared: { initialSharedVersion: String(owner.initialSharedVersion) }
      };
  }
}
function parseTransaction(transaction) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const objectTypes = {};
  (_a = transaction.effects) == null ? void 0 : _a.unchangedConsensusObjects.nodes.forEach((node) => {
    var _a2, _b2, _c2, _d2, _e2;
    if (node.__typename === "ConsensusObjectRead") {
      const type = (_c2 = (_b2 = (_a2 = node.object) == null ? void 0 : _a2.asMoveObject) == null ? void 0 : _b2.contents) == null ? void 0 : _c2.type.repr;
      const address = (_e2 = (_d2 = node.object) == null ? void 0 : _d2.asMoveObject) == null ? void 0 : _e2.address;
      if (type && address) {
        objectTypes[address] = type;
      }
    }
  });
  (_b = transaction.effects) == null ? void 0 : _b.objectChanges.nodes.forEach((node) => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const address = node.address;
    const type = ((_c2 = (_b2 = (_a2 = node.inputState) == null ? void 0 : _a2.asMoveObject) == null ? void 0 : _b2.contents) == null ? void 0 : _c2.type.repr) ?? ((_f2 = (_e2 = (_d2 = node.outputState) == null ? void 0 : _d2.asMoveObject) == null ? void 0 : _e2.contents) == null ? void 0 : _f2.type.repr);
    if (address && type) {
      objectTypes[address] = type;
    }
  });
  if ((_c = transaction.effects) == null ? void 0 : _c.balanceChanges.pageInfo.hasNextPage) {
    throw new Error("Pagination for balance changes is not supported");
  }
  return {
    digest: transaction.digest,
    effects: parseTransactionEffectsBcs(fromBase642((_d = transaction.effects) == null ? void 0 : _d.bcs)),
    epoch: ((_g = (_f = (_e = transaction.effects) == null ? void 0 : _e.epoch) == null ? void 0 : _f.epochId) == null ? void 0 : _g.toString()) ?? null,
    objectTypes: Promise.resolve(objectTypes),
    transaction: parseTransactionBcs(fromBase642(transaction.bcs)),
    signatures: transaction.signatures,
    balanceChanges: ((_h = transaction.effects) == null ? void 0 : _h.balanceChanges.nodes.map((change) => {
      var _a2, _b2;
      return {
        coinType: (_a2 = change == null ? void 0 : change.coinType) == null ? void 0 : _a2.repr,
        address: (_b2 = change.owner) == null ? void 0 : _b2.address,
        amount: change.amount
      };
    })) ?? []
    // events: transaction.events?.pageInfo.hasNextPage
  };
}
function parseNormalizedSuiMoveType(type) {
  let reference = null;
  if (type.ref === "&") {
    reference = "immutable";
  } else if (type.ref === "&mut") {
    reference = "mutable";
  }
  return {
    reference,
    body: parseNormalizedSuiMoveTypeBody(type.body)
  };
}
function parseNormalizedSuiMoveTypeBody(type) {
  switch (type) {
    case "address":
      return { $kind: "address" };
    case "bool":
      return { $kind: "bool" };
    case "u8":
      return { $kind: "u8" };
    case "u16":
      return { $kind: "u16" };
    case "u32":
      return { $kind: "u32" };
    case "u64":
      return { $kind: "u64" };
    case "u128":
      return { $kind: "u128" };
    case "u256":
      return { $kind: "u256" };
  }
  if (typeof type === "string") {
    throw new Error(`Unknown type: ${type}`);
  }
  if ("vector" in type) {
    return {
      $kind: "vector",
      vector: parseNormalizedSuiMoveTypeBody(type.vector)
    };
  }
  if ("datatype" in type) {
    return {
      $kind: "datatype",
      datatype: {
        typeName: `${normalizeSuiAddress(type.datatype.package)}::${type.datatype.module}::${type.datatype.type}`,
        typeParameters: type.datatype.typeParameters.map((t) => parseNormalizedSuiMoveTypeBody(t))
      }
    };
  }
  if ("typeParameter" in type) {
    return {
      $kind: "typeParameter",
      index: type.typeParameter
    };
  }
  throw new Error(`Unknown type: ${JSON.stringify(type)}`);
}

// node_modules/@mysten/sui/dist/esm/graphql/client.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _url;
var _queries;
var _headers;
var _fetch;
var SuiGraphQLRequestError = class extends Error {
};
var SuiGraphQLClient = class extends Experimental_BaseClient {
  constructor({
    url,
    fetch: fetchFn = fetch,
    headers = {},
    queries = {},
    network = "unknown",
    mvr
  }) {
    super({
      network
    });
    __privateAdd3(this, _url);
    __privateAdd3(this, _queries);
    __privateAdd3(this, _headers);
    __privateAdd3(this, _fetch);
    __privateSet3(this, _url, url);
    __privateSet3(this, _queries, queries);
    __privateSet3(this, _headers, headers);
    __privateSet3(this, _fetch, (...args) => fetchFn(...args));
    this.core = new GraphQLCoreClient({
      graphqlClient: this,
      mvr
    });
  }
  async query(options) {
    const res = await __privateGet3(this, _fetch).call(this, __privateGet3(this, _url), {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...__privateGet3(this, _headers)
      },
      body: JSON.stringify({
        query: typeof options.query === "string" || options.query instanceof String ? String(options.query) : print(options.query),
        variables: options.variables,
        extensions: options.extensions,
        operationName: options.operationName
      }),
      signal: options.signal
    });
    if (!res.ok) {
      throw new SuiGraphQLRequestError(`GraphQL request failed: ${res.statusText} (${res.status})`);
    }
    return await res.json();
  }
  async execute(query, options) {
    return this.query({
      ...options,
      query: __privateGet3(this, _queries)[query]
    });
  }
};
_url = /* @__PURE__ */ new WeakMap();
_queries = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_fetch = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/sui/dist/esm/zklogin/jwt-decode.js
var InvalidTokenError = class extends Error {
};
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(
    atob(str).replace(/(.)/g, (_m, p) => {
      let code = p.charCodeAt(0).toString(16).toUpperCase();
      if (code.length < 2) {
        code = "0" + code;
      }
      return "%" + code;
    })
  );
}
function base64UrlDecode(str) {
  let output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output);
  } catch {
    return atob(output);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e) {
    throw new InvalidTokenError(
      `Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`
    );
  }
  try {
    return JSON.parse(decoded);
  } catch (e) {
    throw new InvalidTokenError(
      `Invalid token specified: invalid json for part #${pos + 1} (${e.message})`
    );
  }
}

// node_modules/@mysten/sui/dist/esm/zklogin/poseidon.js
var import_poseidon_lite = __toESM(require_poseidon_lite(), 1);

// node_modules/@mysten/sui/dist/esm/zklogin/utils.js
function findFirstNonZeroIndex(bytes) {
  for (let i = 0; i < bytes.length; i++) {
    if (bytes[i] !== 0) {
      return i;
    }
  }
  return -1;
}
function toPaddedBigEndianBytes(num2, width) {
  const hex = num2.toString(16);
  return hexToBytes(hex.padStart(width * 2, "0").slice(-width * 2));
}
function toBigEndianBytes(num2, width) {
  const bytes = toPaddedBigEndianBytes(num2, width);
  const firstNonZeroIndex = findFirstNonZeroIndex(bytes);
  if (firstNonZeroIndex === -1) {
    return new Uint8Array([0]);
  }
  return bytes.slice(firstNonZeroIndex);
}
function normalizeZkLoginIssuer(iss) {
  if (iss === "accounts.google.com") {
    return "https://accounts.google.com";
  }
  return iss;
}

// node_modules/@mysten/sui/dist/esm/zklogin/jwt-utils.js
function base64UrlCharTo6Bits(base64UrlChar) {
  if (base64UrlChar.length !== 1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const base64UrlCharacterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  const index = base64UrlCharacterSet.indexOf(base64UrlChar);
  if (index === -1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const binaryString = index.toString(2).padStart(6, "0");
  const bits = Array.from(binaryString).map(Number);
  return bits;
}
function base64UrlStringToBitVector(base64UrlString) {
  let bitVector = [];
  for (let i = 0; i < base64UrlString.length; i++) {
    const base64UrlChar = base64UrlString.charAt(i);
    const bits = base64UrlCharTo6Bits(base64UrlChar);
    bitVector = bitVector.concat(bits);
  }
  return bitVector;
}
function decodeBase64URL(s, i) {
  if (s.length < 2) {
    throw new Error(`Input (s = ${s}) is not tightly packed because s.length < 2`);
  }
  let bits = base64UrlStringToBitVector(s);
  const firstCharOffset = i % 4;
  if (firstCharOffset === 0) {
  } else if (firstCharOffset === 1) {
    bits = bits.slice(2);
  } else if (firstCharOffset === 2) {
    bits = bits.slice(4);
  } else {
    throw new Error(`Input (s = ${s}) is not tightly packed because i%4 = 3 (i = ${i}))`);
  }
  const lastCharOffset = (i + s.length - 1) % 4;
  if (lastCharOffset === 3) {
  } else if (lastCharOffset === 2) {
    bits = bits.slice(0, bits.length - 2);
  } else if (lastCharOffset === 1) {
    bits = bits.slice(0, bits.length - 4);
  } else {
    throw new Error(
      `Input (s = ${s}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${i}))`
    );
  }
  if (bits.length % 8 !== 0) {
    throw new Error(`We should never reach here...`);
  }
  const bytes = new Uint8Array(Math.floor(bits.length / 8));
  let currentByteIndex = 0;
  for (let i2 = 0; i2 < bits.length; i2 += 8) {
    const bitChunk = bits.slice(i2, i2 + 8);
    const byte = parseInt(bitChunk.join(""), 2);
    bytes[currentByteIndex++] = byte;
  }
  return new TextDecoder().decode(bytes);
}
function verifyExtendedClaim(claim) {
  if (!(claim.slice(-1) === "}" || claim.slice(-1) === ",")) {
    throw new Error("Invalid claim");
  }
  const json = JSON.parse("{" + claim.slice(0, -1) + "}");
  if (Object.keys(json).length !== 1) {
    throw new Error("Invalid claim");
  }
  const key = Object.keys(json)[0];
  return [key, json[key]];
}
function extractClaimValue(claim, claimName) {
  const extendedClaim = decodeBase64URL(claim.value, claim.indexMod4);
  const [name, value] = verifyExtendedClaim(extendedClaim);
  if (name !== claimName) {
    throw new Error(`Invalid field name: found ${name} expected ${claimName}`);
  }
  return value;
}
function decodeJwt(jwt) {
  const { iss, aud, sub, ...decodedJWT } = jwtDecode(jwt);
  if (!sub || !iss || !aud) {
    throw new Error("Missing jwt data");
  }
  if (Array.isArray(aud)) {
    throw new Error("Not supported aud. Aud is an array, string was expected.");
  }
  return {
    ...decodedJWT,
    iss: normalizeZkLoginIssuer(iss),
    rawIss: iss,
    aud,
    sub
  };
}

// node_modules/@mysten/sui/dist/esm/zklogin/bcs.js
var zkLoginSignature = bcs.struct("ZkLoginSignature", {
  inputs: bcs.struct("ZkLoginSignatureInputs", {
    proofPoints: bcs.struct("ZkLoginSignatureInputsProofPoints", {
      a: bcs.vector(bcs.string()),
      b: bcs.vector(bcs.vector(bcs.string())),
      c: bcs.vector(bcs.string())
    }),
    issBase64Details: bcs.struct("ZkLoginSignatureInputsClaim", {
      value: bcs.string(),
      indexMod4: bcs.u8()
    }),
    headerBase64: bcs.string(),
    addressSeed: bcs.string()
  }),
  maxEpoch: bcs.u64(),
  userSignature: bcs.byteVector()
});

// node_modules/@mysten/sui/dist/esm/zklogin/signature.js
function getZkLoginSignatureBytes({ inputs, maxEpoch, userSignature }) {
  return zkLoginSignature.serialize(
    {
      inputs,
      maxEpoch,
      userSignature: typeof userSignature === "string" ? fromBase64(userSignature) : userSignature
    },
    { maxSize: 2048 }
  ).toBytes();
}
function getZkLoginSignature({ inputs, maxEpoch, userSignature }) {
  const bytes = getZkLoginSignatureBytes({ inputs, maxEpoch, userSignature });
  const signatureBytes = new Uint8Array(bytes.length + 1);
  signatureBytes.set([SIGNATURE_SCHEME_TO_FLAG.ZkLogin]);
  signatureBytes.set(bytes, 1);
  return toBase64(signatureBytes);
}
function parseZkLoginSignature(signature) {
  return zkLoginSignature.parse(typeof signature === "string" ? fromBase64(signature) : signature);
}

// node_modules/@mysten/sui/dist/esm/zklogin/publickey.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var _data;
var _client;
var _legacyAddress;
var _ZkLoginPublicIdentifier_instances;
var toLegacyAddress_fn;
var _ZkLoginPublicIdentifier = class _ZkLoginPublicIdentifier2 extends PublicKey {
  /**
   * Create a new ZkLoginPublicIdentifier object
   * @param value zkLogin public identifier as buffer or base-64 encoded string
   */
  constructor(value, { client } = {}) {
    super();
    __privateAdd4(this, _ZkLoginPublicIdentifier_instances);
    __privateAdd4(this, _data);
    __privateAdd4(this, _client);
    __privateAdd4(this, _legacyAddress);
    __privateSet4(this, _client, client);
    if (typeof value === "string") {
      __privateSet4(this, _data, fromBase64(value));
    } else if (value instanceof Uint8Array) {
      __privateSet4(this, _data, value);
    } else {
      __privateSet4(this, _data, Uint8Array.from(value));
    }
    __privateSet4(this, _legacyAddress, __privateGet4(this, _data).length !== __privateGet4(this, _data)[0] + 1 + 32);
    if (__privateGet4(this, _legacyAddress)) {
      __privateSet4(this, _data, normalizeZkLoginPublicKeyBytes(__privateGet4(this, _data)));
    }
  }
  static fromBytes(bytes, {
    client,
    address,
    legacyAddress
  } = {}) {
    let publicKey;
    if (legacyAddress === true) {
      publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, true), {
        client
      });
    } else if (legacyAddress === false) {
      publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, false), {
        client
      });
    } else if (address) {
      publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, false), {
        client
      });
      if (publicKey.toSuiAddress() !== address) {
        publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, true), {
          client
        });
      }
    } else {
      publicKey = new _ZkLoginPublicIdentifier2(bytes, {
        client
      });
    }
    if (address && publicKey.toSuiAddress() !== address) {
      throw new Error("Public key bytes do not match the provided address");
    }
    return publicKey;
  }
  static fromProof(address, proof) {
    const { issBase64Details, addressSeed } = proof;
    const iss = extractClaimValue(issBase64Details, "iss");
    const legacyPublicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {
      legacyAddress: true
    });
    if (legacyPublicKey.toSuiAddress() === address) {
      return legacyPublicKey;
    }
    const publicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {
      legacyAddress: false
    });
    if (publicKey.toSuiAddress() !== address) {
      throw new Error("Proof does not match address");
    }
    return publicKey;
  }
  /**
   * Checks if two zkLogin public identifiers are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  toSuiAddress() {
    if (__privateGet4(this, _legacyAddress)) {
      return __privateMethod3(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);
    }
    return super.toSuiAddress();
  }
  /**
   * Return the byte array representation of the zkLogin public identifier
   */
  toRawBytes() {
    return __privateGet4(this, _data);
  }
  /**
   * Return the Sui address associated with this ZkLogin public identifier
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ZkLogin"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(_message, _signature) {
    throw Error("does not support");
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase64(message),
      signature: parsedSignature.serializedSignature,
      intentScope: "PersonalMessage",
      client: __privateGet4(this, _client)
    });
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase64(transaction),
      signature: parsedSignature.serializedSignature,
      intentScope: "TransactionData",
      client: __privateGet4(this, _client)
    });
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return address === super.toSuiAddress() || address === __privateMethod3(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);
  }
};
_data = /* @__PURE__ */ new WeakMap();
_client = /* @__PURE__ */ new WeakMap();
_legacyAddress = /* @__PURE__ */ new WeakMap();
_ZkLoginPublicIdentifier_instances = /* @__PURE__ */ new WeakSet();
toLegacyAddress_fn = function() {
  const legacyBytes = normalizeZkLoginPublicKeyBytes(__privateGet4(this, _data), true);
  const addressBytes = new Uint8Array(legacyBytes.length + 1);
  addressBytes[0] = this.flag();
  addressBytes.set(legacyBytes, 1);
  return normalizeSuiAddress(
    bytesToHex(blake2b(addressBytes, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
  );
};
var ZkLoginPublicIdentifier = _ZkLoginPublicIdentifier;
function toZkLoginPublicIdentifier(addressSeed, iss, options) {
  const addressSeedBytesBigEndian = (options == null ? void 0 : options.legacyAddress) ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);
  const issBytes = new TextEncoder().encode(normalizeZkLoginIssuer(iss));
  const tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);
  tmp.set([issBytes.length], 0);
  tmp.set(issBytes, 1);
  tmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);
  return new ZkLoginPublicIdentifier(tmp, options);
}
function normalizeZkLoginPublicKeyBytes(bytes, legacyAddress = false) {
  const issByteLength = bytes[0] + 1;
  const addressSeed = BigInt(`0x${toHex(bytes.slice(issByteLength))}`);
  const seedBytes = legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);
  const data = new Uint8Array(issByteLength + seedBytes.length);
  data.set(bytes.slice(0, issByteLength), 0);
  data.set(seedBytes, issByteLength);
  return data;
}
async function graphqlVerifyZkLoginSignature({
  address,
  bytes,
  signature,
  intentScope,
  client = new SuiGraphQLClient({
    url: "https://sui-mainnet.mystenlabs.com/graphql"
  })
}) {
  const resp = await client.core.verifyZkLoginSignature({
    bytes,
    signature,
    intentScope,
    author: address
  });
  return resp.success === true && resp.errors.length === 0;
}
function parseSerializedZkLoginSignature(signature) {
  const bytes = typeof signature === "string" ? fromBase64(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {
    throw new Error("Invalid signature scheme");
  }
  const signatureBytes = bytes.slice(1);
  const { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);
  const { issBase64Details, addressSeed } = inputs;
  const iss = extractClaimValue(issBase64Details, "iss");
  const publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);
  return {
    serializedSignature: toBase64(bytes),
    signatureScheme: "ZkLogin",
    zkLogin: {
      inputs,
      maxEpoch,
      userSignature,
      iss,
      addressSeed: BigInt(addressSeed)
    },
    signature: bytes,
    publicKey: publicIdentifer.toRawBytes()
  };
}

// node_modules/@mysten/sui/dist/esm/cryptography/signature.js
function toSerializedSignature({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toBase64(serializedSignature);
}
function parseSerializedSignature(serializedSignature) {
  const bytes = fromBase64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "Passkey":
      return parseSerializedPasskeySignature(serializedSignature);
    case "MultiSig":
      const multisig = suiBcs.MultiSig.parse(bytes.slice(1));
      return {
        serializedSignature,
        signatureScheme,
        multisig,
        bytes,
        signature: void 0
      };
    case "ZkLogin":
      return parseSerializedZkLoginSignature(serializedSignature);
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      return parseSerializedKeypairSignature(serializedSignature);
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/@mysten/sui/dist/esm/cryptography/mnemonics.js
function isValidHardenedPath(path) {
  if (!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(path)) {
    return false;
  }
  return true;
}
function mnemonicToSeed(mnemonics) {
  return mnemonicToSeedSync(mnemonics, "");
}
function mnemonicToSeedHex(mnemonics) {
  return toHex(mnemonicToSeed(mnemonics));
}

// node_modules/@mysten/sui/dist/esm/cryptography/keypair.js
var PRIVATE_KEY_SIZE = 32;
var SUI_PRIVATE_KEY_PREFIX = "suiprivkey";
var Signer = class {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    const signature = toSerializedSignature({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toBase64(bytes)
    };
  }
  /**
   * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransaction(bytes) {
    return this.signWithIntent(bytes, "TransactionData");
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes) {
    const { signature } = await this.signWithIntent(
      bcs.byteVector().serialize(bytes).toBytes(),
      "PersonalMessage"
    );
    return {
      bytes: toBase64(bytes),
      signature
    };
  }
  async signAndExecuteTransaction({
    transaction,
    client
  }) {
    const bytes = await transaction.build({ client });
    const { signature } = await this.signTransaction(bytes);
    const response = await client.core.executeTransaction({
      transaction: bytes,
      signatures: [signature]
    });
    return response.transaction;
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
};
var Keypair = class extends Signer {
};
function decodeSuiPrivateKey(value) {
  const { prefix, words } = bech32.decode(value);
  if (prefix !== SUI_PRIVATE_KEY_PREFIX) {
    throw new Error("invalid private key prefix");
  }
  const extendedSecretKey = new Uint8Array(bech32.fromWords(words));
  const secretKey = extendedSecretKey.slice(1);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0]];
  return {
    scheme: signatureScheme,
    schema: signatureScheme,
    secretKey
  };
}
function encodeSuiPrivateKey(bytes, scheme) {
  if (bytes.length !== PRIVATE_KEY_SIZE) {
    throw new Error("Invalid bytes length");
  }
  const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];
  const privKeyBytes = new Uint8Array(bytes.length + 1);
  privKeyBytes.set([flag]);
  privKeyBytes.set(bytes, 1);
  return bech32.encode(SUI_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n, P) * b3 % P;
  const b9 = pow2(b6, _3n, P) * b3 % P;
  const b11 = pow2(b9, _2n, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE(n, 32);
var modP = (x) => mod(x, secp256k1_CURVE.p);
var modN = (x) => mod(x, secp256k1_CURVE.n);
var Point = (() => secp256k1.Point)();
var hasEven = (y) => y % _2n === _0n;
function schnorrGetExtPubKey(priv) {
  let d_ = _normFnElement(Point.Fn, priv);
  let p = Point.BASE.multiply(d_);
  const scalar = hasEven(p.y) ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  aInRange("x", x, _1n, secp256k1_CURVE.p);
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (!hasEven(y))
    y = modP(-y);
  const p = Point.fromAffine({ x, y });
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return modN(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(num(rand));
  if (k_ === _0n)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n, secp256k1_CURVE.p))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n, secp256k1_CURVE.n))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = Point.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  secp256k1.utils.randomSecretKey;
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
  }
  return {
    keygen,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point,
    utils: {
      randomSecretKey,
      randomPrivateKey: randomSecretKey,
      taggedHash,
      // TODO: remove
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      mod
    },
    info: {
      type: "weierstrass",
      publicKeyHasPrefix: false,
      lengths: {
        secret: size,
        public: size,
        signature: size * 2,
        seed: seedLength
      }
    }
  };
})();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher2(secp256k1.Point, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA1_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 80; i++)
      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i = 0; i < 80; i++) {
      let F, K2;
      if (i < 20) {
        F = Chi(B, C, D);
        K2 = 1518500249;
      } else if (i < 40) {
        F = B ^ C ^ D;
        K2 = 1859775393;
      } else if (i < 60) {
        F = Maj(B, C, D);
        K2 = 2400959708;
      } else {
        F = B ^ C ^ D;
        K2 = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K2 + SHA1_W[i] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A, B, C, D } = this;
    return [A, B, C, D];
  }
  set(A, B, C, D) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      MD5_W[i] = view.getUint32(offset, true);
    let { A, B, C, D } = this;
    for (let i = 0; i < 64; i++) {
      let F, g, s;
      if (i < 16) {
        F = Chi(B, C, D);
        g = i;
        s = [7, 12, 17, 22];
      } else if (i < 32) {
        F = Chi(D, B, C);
        g = (5 * i + 1) % 16;
        s = [5, 9, 14, 20];
      } else if (i < 48) {
        F = B ^ C ^ D;
        g = (3 * i + 5) % 16;
        s = [4, 11, 16, 23];
      } else {
        F = C ^ (B | ~D);
        g = 7 * i % 16;
        s = [6, 10, 15, 21];
      }
      F = F + A + K[i] + MD5_W[g];
      A = D;
      D = C;
      C = B;
      B = B + rotl(F, s[i % 4]);
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    this.set(A, B, C, D);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
var Pi160 = (() => Id160.map((i) => (9 * i + 5) % 16))();
var idxLR = (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i = 0; i < 4; i++)
    for (let j of res)
      j.push(j[i].map((k) => Rho160[k]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => Uint8Array.from(i));
var shiftsL160 = idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
var shiftsR160 = idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF_160[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@scure/bip32/lib/esm/index.js
var Point2 = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha256);
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");

// node_modules/@mysten/sui/dist/esm/keypairs/secp256r1/publickey.js
var SECP256R1_PUBLIC_KEY_SIZE = 33;
var Secp256r1PublicKey = class extends PublicKey {
  /**
   * Create a new Secp256r1PublicKey object
   * @param value secp256r1 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256r1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256r1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "Secp256r1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256r1.verify(
      secp256r1.Signature.fromCompact(bytes),
      sha2562(message),
      this.toRawBytes()
    );
  }
};
Secp256r1PublicKey.SIZE = SECP256R1_PUBLIC_KEY_SIZE;

// node_modules/@mysten/signers/dist/esm/webcrypto/index.js
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet5 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _publicKey;
function getCompressedPublicKey(publicKey) {
  const rawBytes = new Uint8Array(publicKey);
  const x = rawBytes.slice(1, 33);
  const y = rawBytes.slice(33, 65);
  const prefix = (y[31] & 1) === 0 ? 2 : 3;
  const compressed = new Uint8Array(Secp256r1PublicKey.SIZE);
  compressed[0] = prefix;
  compressed.set(x, 1);
  return compressed;
}
var _WebCryptoSigner = class _WebCryptoSigner2 extends Signer {
  constructor(privateKey, publicKey) {
    super();
    __privateAdd5(this, _publicKey);
    this.privateKey = privateKey;
    __privateSet5(this, _publicKey, new Secp256r1PublicKey(publicKey));
  }
  static async generate({ extractable = false } = {}) {
    const keypair = await globalThis.crypto.subtle.generateKey(
      {
        name: "ECDSA",
        namedCurve: "P-256"
      },
      extractable,
      ["sign", "verify"]
    );
    const publicKey = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
    return new _WebCryptoSigner2(
      keypair.privateKey,
      getCompressedPublicKey(new Uint8Array(publicKey))
    );
  }
  /**
   * Imports a keypair using the value returned by `export()`.
   */
  static import(data) {
    return new _WebCryptoSigner2(data.privateKey, data.publicKey);
  }
  getKeyScheme() {
    return "Secp256r1";
  }
  /**
   * Exports the keypair so that it can be stored in IndexedDB.
   */
  export() {
    const exportedKeypair = {
      privateKey: this.privateKey,
      publicKey: __privateGet5(this, _publicKey).toRawBytes()
    };
    Object.defineProperty(exportedKeypair, "toJSON", {
      enumerable: false,
      value: () => {
        throw new Error(
          "The exported keypair must not be serialized. It must be stored in IndexedDB directly."
        );
      }
    });
    return exportedKeypair;
  }
  getPublicKey() {
    return __privateGet5(this, _publicKey);
  }
  async sign(bytes) {
    const rawSignature = await globalThis.crypto.subtle.sign(
      {
        name: "ECDSA",
        hash: "SHA-256"
      },
      this.privateKey,
      bytes
    );
    const signature = secp256r1.Signature.fromCompact(new Uint8Array(rawSignature));
    return signature.normalizeS().toCompactRawBytes();
  }
};
_publicKey = /* @__PURE__ */ new WeakMap();
var WebCryptoSigner = _WebCryptoSigner;

// node_modules/@mysten/sui/dist/esm/keypairs/ed25519/ed25519-hd-key.js
var ED25519_CURVE = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var pathRegex = new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive = (val) => val.replace("'", "");
var getMasterKeyFromSeed = (seed) => {
  const h = hmac.create(sha512, ED25519_CURVE);
  const I = h.update(fromHex(seed)).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv = ({ key, chainCode }, index) => {
  const indexBuffer = new ArrayBuffer(4);
  const cv = new DataView(indexBuffer);
  cv.setUint32(0, index);
  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);
  data.set(new Uint8Array(1).fill(0));
  data.set(key, 1);
  data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);
  const I = hmac.create(sha512, chainCode).update(data).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath = (path) => {
  if (!pathRegex.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(
    isNaN
    /* ts T_T*/
  );
};
var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {
    key,
    chainCode
  });
};

// node_modules/@mysten/sui/dist/esm/keypairs/ed25519/publickey.js
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class extends PublicKey {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ED25519"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedKeypairSignature(signature);
      if (parsed.signatureScheme !== "ED25519") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return ed25519.verify(bytes, message, this.toRawBytes());
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// node_modules/@mysten/sui/dist/esm/keypairs/ed25519/keypair.js
var DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair = class _Ed25519Keypair extends Keypair {
  /**
   * Create a new Ed25519 keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair Ed25519 keypair
   */
  constructor(keypair) {
    super();
    if (keypair) {
      this.keypair = {
        publicKey: keypair.publicKey,
        secretKey: keypair.secretKey.slice(0, 32)
      };
    } else {
      const privateKey = ed25519.utils.randomPrivateKey();
      this.keypair = {
        publicKey: ed25519.getPublicKey(privateKey),
        secretKey: privateKey
      };
    }
  }
  /**
   * Get the key scheme of the keypair ED25519
   */
  getKeyScheme() {
    return "ED25519";
  }
  /**
   * Generate a new random Ed25519 keypair
   */
  static generate() {
    const secretKey = ed25519.utils.randomPrivateKey();
    return new _Ed25519Keypair({
      publicKey: ed25519.getPublicKey(secretKey),
      secretKey
    });
  }
  /**
   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.
   * This is NOT the private scalar which is result of hashing and bit clamping of
   * the raw secret key.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key as a byte array or Bech32 secret key string
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    if (typeof secretKey === "string") {
      const decoded = decodeSuiPrivateKey(secretKey);
      if (decoded.schema !== "ED25519") {
        throw new Error(`Expected a ED25519 keypair, got ${decoded.schema}`);
      }
      return this.fromSecretKey(decoded.secretKey, options);
    }
    const secretKeyLength = secretKey.length;
    if (secretKeyLength !== PRIVATE_KEY_SIZE) {
      throw new Error(
        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`
      );
    }
    const keypair = {
      publicKey: ed25519.getPublicKey(secretKey),
      secretKey
    };
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const signature = ed25519.sign(signData, secretKey);
      if (!ed25519.verify(signature, signData, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new _Ed25519Keypair(keypair);
  }
  /**
   * The public key for this Ed25519 keypair
   */
  getPublicKey() {
    return new Ed25519PublicKey(this.keypair.publicKey);
  }
  /**
   * The Bech32 secret key string for this Ed25519 keypair
   */
  getSecretKey() {
    return encodeSuiPrivateKey(
      this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE),
      this.getKeyScheme()
    );
  }
  /**
   * Return the signature for the provided data using Ed25519.
   */
  async sign(data) {
    return ed25519.sign(data, this.keypair.secretKey);
  }
  /**
   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));
    return _Ed25519Keypair.fromSecretKey(key);
  }
  /**
   * Derive Ed25519 keypair from mnemonicSeed and path.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypairFromSeed(seedHex, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, seedHex);
    return _Ed25519Keypair.fromSecretKey(key);
  }
};

// node_modules/@mysten/sui/dist/esm/zklogin/address.js
var MAX_PADDED_UNSIGNED_JWT_LEN = 64 * 25;

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}

// node_modules/nanostores/task/index.js
var tasks = 0;
var resolves = [];
function startTask() {
  tasks += 1;
  return () => {
    tasks -= 1;
    if (tasks === 0) {
      let prevResolves = resolves;
      resolves = [];
      for (let i of prevResolves) i();
    }
  };
}
function task(cb) {
  let endTask = startTask();
  let promise = cb().finally(endTask);
  promise.t = true;
  return promise;
}
function allTasks() {
  if (tasks === 0) {
    return Promise.resolve();
  } else {
    return new Promise((resolve) => {
      resolves.push(resolve);
    });
  }
}

// node_modules/nanostores/clean-stores/index.js
var clean2 = Symbol("clean");

// node_modules/nanostores/atom/index.js
var listenerQueue = [];
var lqIndex = 0;
var QUEUE_ITEMS_PER_LISTENER = 4;
var epoch = 0;
var atom = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(listener, $atom.value, oldValue, changedKey);
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean2] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// node_modules/nanostores/lifecycle/index.js
var SET = 2;
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var onSet = ($store, listener) => on($store, listener, SET, (runListeners) => {
  let originSet = $store.set;
  let originSetKey = $store.setKey;
  if ($store.setKey) {
    $store.setKey = (changed, changedValue) => {
      let isAborted;
      let abort = () => {
        isAborted = true;
      };
      runListeners({
        abort,
        changed,
        newValue: { ...$store.value, [changed]: changedValue }
      });
      if (!isAborted) return originSetKey(changed, changedValue);
    };
  }
  $store.set = (newValue) => {
    let isAborted;
    let abort = () => {
      isAborted = true;
    };
    runListeners({ abort, newValue });
    if (!isAborted) return originSet(newValue);
  };
  return () => {
    $store.set = originSet;
    $store.setKey = originSetKey;
  };
});
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = ($store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy) $store.events[UNMOUNT].push(destroy);
  };
  return on($store, listener, MOUNT, (runListeners) => {
    let originListen = $store.listen;
    $store.listen = (...args) => {
      if (!$store.lc && !$store.active) {
        $store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = $store.off;
    $store.events[UNMOUNT] = [];
    $store.off = () => {
      originOff();
      setTimeout(() => {
        if ($store.active && !$store.lc) {
          $store.active = false;
          for (let destroy of $store.events[UNMOUNT]) destroy();
          $store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = $store[clean2];
      $store[clean2] = () => {
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
        $store.active = false;
        originClean();
      };
    }
    return () => {
      $store.listen = originListen;
      $store.off = originOff;
    };
  });
};

// node_modules/@mysten/enoki/dist/esm/encryption.js
function createDefaultEncryption() {
  async function keyFromPassword(password, salt) {
    const key = await crypto.subtle.importKey(
      "raw",
      new TextEncoder().encode(password),
      { name: "PBKDF2" },
      false,
      ["deriveBits", "deriveKey"]
    );
    const derivedKey = await crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 9e5,
        hash: "SHA-256"
      },
      key,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
    return { key, derivedKey };
  }
  return {
    async encrypt(password, data) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const { derivedKey } = await keyFromPassword(password, salt);
      const payload = await crypto.subtle.encrypt(
        {
          name: "AES-GCM",
          iv
        },
        derivedKey,
        new TextEncoder().encode(data)
      );
      return JSON.stringify({
        payload: toBase64(new Uint8Array(payload)),
        iv: toBase64(iv),
        salt: toBase64(salt)
      });
    },
    async decrypt(password, data) {
      const parsed = JSON.parse(data);
      if (!parsed.payload || !parsed.iv || !parsed.salt) {
        throw new Error("Invalid encrypted data");
      }
      const { derivedKey } = await keyFromPassword(password, fromBase64(parsed.salt));
      const decryptedContent = await crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv: fromBase64(parsed.iv)
        },
        derivedKey,
        fromBase64(parsed.payload)
      );
      return new TextDecoder().decode(decryptedContent);
    }
  };
}

// node_modules/@mysten/enoki/dist/esm/EnokiKeypair.js
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd6 = (obj, member, value) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet6 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _proof;
var _maxEpoch;
var _ephemeralKeypair;
var _publicKey2;
var EnokiPublicKey = class extends ZkLoginPublicIdentifier {
};
var EnokiKeypair = class extends Signer {
  constructor(input) {
    super();
    __privateAdd6(this, _proof);
    __privateAdd6(this, _maxEpoch);
    __privateAdd6(this, _ephemeralKeypair);
    __privateAdd6(this, _publicKey2);
    __privateSet6(this, _proof, input.proof);
    __privateSet6(this, _maxEpoch, input.maxEpoch);
    __privateSet6(this, _ephemeralKeypair, input.ephemeralKeypair);
    __privateSet6(this, _publicKey2, EnokiPublicKey.fromProof(input.address, input.proof));
  }
  async sign(data) {
    return __privateGet6(this, _ephemeralKeypair).sign(data);
  }
  async signPersonalMessage(bytes) {
    const { bytes: signedBytes, signature: userSignature } = await __privateGet6(this, _ephemeralKeypair).signPersonalMessage(bytes);
    const zkSignature = getZkLoginSignature({
      inputs: __privateGet6(this, _proof),
      maxEpoch: __privateGet6(this, _maxEpoch),
      userSignature
    });
    return {
      bytes: signedBytes,
      signature: zkSignature
    };
  }
  async signTransaction(bytes) {
    const { bytes: signedBytes, signature: userSignature } = await __privateGet6(this, _ephemeralKeypair).signTransaction(bytes);
    const zkSignature = getZkLoginSignature({
      inputs: __privateGet6(this, _proof),
      maxEpoch: __privateGet6(this, _maxEpoch),
      userSignature
    });
    return {
      bytes: signedBytes,
      signature: zkSignature
    };
  }
  getKeyScheme() {
    return __privateGet6(this, _ephemeralKeypair).getKeyScheme();
  }
  getPublicKey() {
    return __privateGet6(this, _publicKey2);
  }
};
_proof = /* @__PURE__ */ new WeakMap();
_maxEpoch = /* @__PURE__ */ new WeakMap();
_ephemeralKeypair = /* @__PURE__ */ new WeakMap();
_publicKey2 = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/enoki/dist/esm/stores.js
function createWebStorage(storage) {
  return {
    get(key) {
      return storage.getItem(key);
    },
    set(key, value) {
      storage.setItem(key, value);
    },
    delete(key) {
      storage.removeItem(key);
    }
  };
}
function createInMemoryStorage() {
  const store = /* @__PURE__ */ new Map();
  return {
    get(key) {
      return store.get(key) ?? null;
    },
    set(key, value) {
      store.set(key, value);
    },
    delete(key) {
      store.delete(key);
    }
  };
}
function createLocalStorage() {
  if (typeof window === "undefined") {
    console.warn("`window.localStorage` is not available, falling back to in-memory storage");
    return createInMemoryStorage();
  }
  return createWebStorage(window.localStorage);
}
function createSessionStorage() {
  if (typeof window === "undefined") {
    console.warn("`window.sessionStorage` is not available, falling back to in-memory storage");
    return createInMemoryStorage();
  }
  return createWebStorage(window.sessionStorage);
}

// node_modules/@mysten/enoki/dist/esm/EnokiFlow.js
var __typeError7 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck7 = (obj, member, msg) => member.has(obj) || __typeError7("Cannot " + msg);
var __privateGet7 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd7 = (obj, member, value) => member.has(obj) ? __typeError7("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet7 = (obj, member, value, setter) => (__accessCheck7(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck7(obj, member, "access private method"), method);
var _storageKeys;
var _enokiClient;
var _encryption;
var _encryptionKey;
var _store;
var _useNativeCryptoSigner;
var _idbStore;
var _EnokiFlow_instances;
var setSession_fn;
var createStorageKeys = (apiKey) => ({
  STATE: `@enoki/flow/state/${apiKey}`,
  SESSION: `@enoki/flow/session/${apiKey}`
});
var EnokiFlow = class {
  constructor(config) {
    __privateAdd7(this, _EnokiFlow_instances);
    __privateAdd7(this, _storageKeys);
    __privateAdd7(this, _enokiClient);
    __privateAdd7(this, _encryption);
    __privateAdd7(this, _encryptionKey);
    __privateAdd7(this, _store);
    __privateAdd7(this, _useNativeCryptoSigner);
    __privateAdd7(this, _idbStore);
    __privateSet7(this, _enokiClient, new EnokiClient({
      apiKey: config.apiKey,
      apiUrl: config.apiUrl
    }));
    __privateSet7(this, _encryptionKey, config.apiKey);
    if (config.experimental_nativeCryptoSigner) {
      __privateSet7(this, _useNativeCryptoSigner, true);
      __privateSet7(this, _idbStore, createStore(config.apiKey, "enoki"));
    } else {
      __privateSet7(this, _useNativeCryptoSigner, false);
    }
    __privateSet7(this, _encryption, config.encryption ?? createDefaultEncryption());
    __privateSet7(this, _store, config.store ?? createSessionStorage());
    __privateSet7(this, _storageKeys, createStorageKeys(config.apiKey));
    let storedState = null;
    try {
      const rawStoredValue = __privateGet7(this, _store).get(__privateGet7(this, _storageKeys).STATE);
      if (rawStoredValue) {
        storedState = JSON.parse(rawStoredValue);
      }
    } catch {
    }
    this.$zkLoginState = atom(storedState || {});
    this.$zkLoginSession = atom({ initialized: false, value: null });
    onMount(this.$zkLoginSession, () => {
      this.getSession();
    });
    onSet(this.$zkLoginState, ({ newValue }) => {
      __privateGet7(this, _store).set(__privateGet7(this, _storageKeys).STATE, JSON.stringify(newValue));
    });
  }
  get enokiClient() {
    return __privateGet7(this, _enokiClient);
  }
  async createAuthorizationURL(input) {
    const ephemeralKeyPair = __privateGet7(this, _useNativeCryptoSigner) ? await WebCryptoSigner.generate() : new Ed25519Keypair();
    const { nonce, randomness, maxEpoch, estimatedExpiration } = await __privateGet7(this, _enokiClient).createZkLoginNonce({
      network: input.network,
      ephemeralPublicKey: ephemeralKeyPair.getPublicKey()
    });
    const params = new URLSearchParams({
      ...input.extraParams,
      nonce,
      client_id: input.clientId,
      redirect_uri: input.redirectUrl,
      response_type: "id_token",
      // TODO: Eventually fetch the scopes for this client ID from the Enoki service:
      scope: [
        "openid",
        // Merge the requested scopes in with the required openid scopes:
        ...input.extraParams && "scope" in input.extraParams ? input.extraParams.scope : []
      ].filter(Boolean).join(" ")
    });
    let oauthUrl;
    switch (input.provider) {
      case "google": {
        oauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
        break;
      }
      case "facebook": {
        oauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;
        break;
      }
      case "twitch": {
        params.set("force_verify", "true");
        oauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;
        break;
      }
      default:
        throw new Error(`Invalid provider: ${input.provider}`);
    }
    this.$zkLoginState.set({ provider: input.provider });
    if (__privateGet7(this, _useNativeCryptoSigner)) {
      await set("ephemeralKeyPair", ephemeralKeyPair.export(), __privateGet7(this, _idbStore));
    }
    await __privateMethod4(this, _EnokiFlow_instances, setSession_fn).call(this, {
      expiresAt: estimatedExpiration,
      maxEpoch,
      randomness,
      ephemeralKeyPair: __privateGet7(this, _useNativeCryptoSigner) ? "@@native" : toBase64(
        decodeSuiPrivateKey(ephemeralKeyPair.getSecretKey()).secretKey
      )
    });
    return oauthUrl;
  }
  // TODO: Should our SDK manage this automatically in addition to exposing a method?
  async handleAuthCallback(hash = window.location.hash) {
    const params = new URLSearchParams(hash.startsWith("#") ? hash.slice(1) : hash);
    const zkp = await this.getSession();
    if (!zkp || !zkp.ephemeralKeyPair || !zkp.maxEpoch || !zkp.randomness) {
      throw new Error(
        "Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this."
      );
    }
    const jwt = params.get("id_token");
    if (!jwt) {
      throw new Error("Missing ID Token");
    }
    decodeJwt(jwt);
    const { address, salt, publicKey } = await __privateGet7(this, _enokiClient).getZkLogin({ jwt });
    this.$zkLoginState.set({
      ...this.$zkLoginState.get(),
      salt,
      address,
      publicKey
    });
    await __privateMethod4(this, _EnokiFlow_instances, setSession_fn).call(this, {
      ...zkp,
      jwt
    });
    return params.get("state");
  }
  async getSession() {
    if (this.$zkLoginSession.get().initialized) {
      return this.$zkLoginSession.get().value;
    }
    try {
      const storedValue = __privateGet7(this, _store).get(__privateGet7(this, _storageKeys).SESSION);
      if (!storedValue) return null;
      const state = JSON.parse(
        await __privateGet7(this, _encryption).decrypt(__privateGet7(this, _encryptionKey), storedValue)
      );
      if ((state == null ? void 0 : state.expiresAt) && Date.now() > state.expiresAt) {
        await this.logout();
      } else {
        this.$zkLoginSession.set({ initialized: true, value: state });
      }
    } catch {
      this.$zkLoginSession.set({ initialized: true, value: null });
    }
    return this.$zkLoginSession.get().value;
  }
  async logout() {
    this.$zkLoginState.set({});
    __privateGet7(this, _store).delete(__privateGet7(this, _storageKeys).STATE);
    if (__privateGet7(this, _useNativeCryptoSigner)) {
      await clear(__privateGet7(this, _idbStore));
    }
    await __privateMethod4(this, _EnokiFlow_instances, setSession_fn).call(this, null);
  }
  // TODO: Should this return the proof if it already exists?
  async getProof({ network } = {}) {
    const zkp = await this.getSession();
    const { salt } = this.$zkLoginState.get();
    if (zkp == null ? void 0 : zkp.proof) {
      if (zkp.expiresAt && Date.now() > zkp.expiresAt) {
        throw new Error("Stored proof is expired.");
      }
      return zkp.proof;
    }
    if (!salt || !zkp || !zkp.jwt) {
      throw new Error("Missing required parameters for proof generation");
    }
    let storedNativeSigner = void 0;
    if (__privateGet7(this, _useNativeCryptoSigner) && zkp.ephemeralKeyPair === "@@native") {
      storedNativeSigner = await get("ephemeralKeyPair", __privateGet7(this, _idbStore));
      if (!storedNativeSigner) {
        throw new Error("Native signer not found in store.");
      }
    }
    const ephemeralKeyPair = zkp.ephemeralKeyPair === "@@native" ? WebCryptoSigner.import(storedNativeSigner) : Ed25519Keypair.fromSecretKey(fromBase64(zkp.ephemeralKeyPair));
    const proof = await __privateGet7(this, _enokiClient).createZkLoginZkp({
      network,
      jwt: zkp.jwt,
      maxEpoch: zkp.maxEpoch,
      randomness: zkp.randomness,
      ephemeralPublicKey: ephemeralKeyPair.getPublicKey()
    });
    await __privateMethod4(this, _EnokiFlow_instances, setSession_fn).call(this, {
      ...zkp,
      proof
    });
    return proof;
  }
  async getKeypair({ network } = {}) {
    await this.getProof({ network });
    const zkp = await this.getSession();
    const { address } = this.$zkLoginState.get();
    if (!address || !zkp || !zkp.proof) {
      throw new Error("Missing required data for keypair generation.");
    }
    if (Date.now() > zkp.expiresAt) {
      throw new Error("Stored proof is expired.");
    }
    let storedNativeSigner = void 0;
    if (__privateGet7(this, _useNativeCryptoSigner) && zkp.ephemeralKeyPair === "@@native") {
      storedNativeSigner = await get("ephemeralKeyPair", __privateGet7(this, _idbStore));
      if (!storedNativeSigner) {
        throw new Error("Native signer not found in store.");
      }
    }
    const ephemeralKeypair = zkp.ephemeralKeyPair === "@@native" ? WebCryptoSigner.import(storedNativeSigner) : Ed25519Keypair.fromSecretKey(fromBase64(zkp.ephemeralKeyPair));
    return new EnokiKeypair({
      address,
      ephemeralKeypair,
      maxEpoch: zkp.maxEpoch,
      proof: zkp.proof
    });
  }
};
_storageKeys = /* @__PURE__ */ new WeakMap();
_enokiClient = /* @__PURE__ */ new WeakMap();
_encryption = /* @__PURE__ */ new WeakMap();
_encryptionKey = /* @__PURE__ */ new WeakMap();
_store = /* @__PURE__ */ new WeakMap();
_useNativeCryptoSigner = /* @__PURE__ */ new WeakMap();
_idbStore = /* @__PURE__ */ new WeakMap();
_EnokiFlow_instances = /* @__PURE__ */ new WeakSet();
setSession_fn = async function(newValue) {
  if (newValue) {
    const storedValue = await __privateGet7(this, _encryption).encrypt(
      __privateGet7(this, _encryptionKey),
      JSON.stringify(newValue)
    );
    __privateGet7(this, _store).set(__privateGet7(this, _storageKeys).SESSION, storedValue);
  } else {
    __privateGet7(this, _store).delete(__privateGet7(this, _storageKeys).SESSION);
  }
  this.$zkLoginSession.set({ initialized: true, value: newValue });
};

// node_modules/@mysten/enoki/node_modules/@mysten/wallet-standard/dist/esm/features/suiSignTransaction.js
var SuiSignTransaction = "sui:signTransaction";

// node_modules/@mysten/enoki/node_modules/@mysten/wallet-standard/dist/esm/features/suiSignAndExecuteTransaction.js
var SuiSignAndExecuteTransaction = "sui:signAndExecuteTransaction";

// node_modules/@mysten/enoki/node_modules/@mysten/wallet-standard/dist/esm/features/suiSignPersonalMessage.js
var SuiSignPersonalMessage = "sui:signPersonalMessage";

// node_modules/@mysten/enoki/dist/esm/wallet/features.js
var EnokiGetMetadata = "enoki:getMetadata";
var EnokiGetSession = "enoki:getSession";

// node_modules/@mysten/enoki/dist/esm/wallet/state.js
var __typeError8 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck8 = (obj, member, msg) => member.has(obj) || __typeError8("Cannot " + msg);
var __privateGet8 = (obj, member, getter) => (__accessCheck8(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd8 = (obj, member, value) => member.has(obj) ? __typeError8("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet8 = (obj, member, value, setter) => (__accessCheck8(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod5 = (obj, member, method) => (__accessCheck8(obj, member, "access private method"), method);
var _encryption2;
var _encryptionKey2;
var _stateStore;
var _sessionContextByNetwork;
var _zkLoginState;
var _EnokiWalletState_instances;
var createZkLoginState_fn;
var sessionKey = "zklogin-session";
var stateKey = "zklogin-state";
var EnokiWalletState = class {
  constructor(config) {
    __privateAdd8(this, _EnokiWalletState_instances);
    __privateAdd8(this, _encryption2);
    __privateAdd8(this, _encryptionKey2);
    __privateAdd8(this, _stateStore);
    __privateAdd8(this, _sessionContextByNetwork);
    __privateAdd8(this, _zkLoginState);
    __privateSet8(this, _encryptionKey2, config.apiKey);
    __privateSet8(this, _encryption2, createDefaultEncryption());
    __privateSet8(this, _stateStore, createStore(`${config.apiKey}_${config.clientId}`, "enoki"));
    __privateSet8(this, _zkLoginState, __privateMethod5(this, _EnokiWalletState_instances, createZkLoginState_fn).call(this));
    __privateSet8(this, _sessionContextByNetwork, config.clients.reduce((accumulator, client) => {
      const network = client.network;
      const idbStore = createStore(`${config.apiKey}_${network}_${config.clientId}`, "enoki");
      const sessionContext = {
        $zkLoginSession: atom({ initialized: false, value: null }),
        client,
        idbStore
      };
      onMount(sessionContext.$zkLoginSession, () => {
        this.getSession(sessionContext);
      });
      return accumulator.set(network, sessionContext);
    }, /* @__PURE__ */ new Map()));
  }
  get zkLoginState() {
    return __privateGet8(this, _zkLoginState);
  }
  get sessionContextByNetwork() {
    return __privateGet8(this, _sessionContextByNetwork);
  }
  getSessionContext(network) {
    const context = __privateGet8(this, _sessionContextByNetwork).get(network);
    if (!context) {
      throw new Error(`The network ${network} isn't supported.`);
    }
    return context;
  }
  async logout() {
    __privateGet8(this, _zkLoginState).set(null);
    await clear(__privateGet8(this, _stateStore));
    for (const context of __privateGet8(this, _sessionContextByNetwork).values()) {
      await this.setSession(context, null);
      await clear(context.idbStore);
    }
  }
  async setSession(context, newValue) {
    if (newValue) {
      const storedValue = await __privateGet8(this, _encryption2).encrypt(
        __privateGet8(this, _encryptionKey2),
        JSON.stringify(newValue)
      );
      await set(sessionKey, storedValue, context.idbStore);
    } else {
      await del(sessionKey, context.idbStore);
    }
    context.$zkLoginSession.set({ initialized: true, value: newValue });
  }
  async getSession({ $zkLoginSession, idbStore }) {
    if ($zkLoginSession.get().initialized) {
      return $zkLoginSession.get().value;
    }
    try {
      const storedValue = await get(sessionKey, idbStore);
      if (!storedValue) return null;
      const state = JSON.parse(
        await __privateGet8(this, _encryption2).decrypt(__privateGet8(this, _encryptionKey2), storedValue)
      );
      if ((state == null ? void 0 : state.expiresAt) && Date.now() > state.expiresAt) {
        await this.logout();
      } else {
        $zkLoginSession.set({ initialized: true, value: state });
      }
    } catch {
      $zkLoginSession.set({ initialized: true, value: null });
    }
    return $zkLoginSession.get().value;
  }
};
_encryption2 = /* @__PURE__ */ new WeakMap();
_encryptionKey2 = /* @__PURE__ */ new WeakMap();
_stateStore = /* @__PURE__ */ new WeakMap();
_sessionContextByNetwork = /* @__PURE__ */ new WeakMap();
_zkLoginState = /* @__PURE__ */ new WeakMap();
_EnokiWalletState_instances = /* @__PURE__ */ new WeakSet();
createZkLoginState_fn = function() {
  const $zkLoginState = atom(null);
  onMount($zkLoginState, () => {
    task(async () => {
      try {
        const rawStoredValue = await get(stateKey, __privateGet8(this, _stateStore));
        if (rawStoredValue) {
          $zkLoginState.set(JSON.parse(rawStoredValue));
        }
      } catch {
      }
    });
  });
  onSet($zkLoginState, ({ newValue }) => {
    set(stateKey, JSON.stringify(newValue), __privateGet8(this, _stateStore));
  });
  return $zkLoginState;
};

// node_modules/@mysten/enoki/dist/esm/wallet/wallet.js
var __typeError9 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck9 = (obj, member, msg) => member.has(obj) || __typeError9("Cannot " + msg);
var __privateGet9 = (obj, member, getter) => (__accessCheck9(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd9 = (obj, member, value) => member.has(obj) ? __typeError9("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet9 = (obj, member, value, setter) => (__accessCheck9(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod6 = (obj, member, method) => (__accessCheck9(obj, member, "access private method"), method);
var _events;
var _accounts;
var _name;
var _icon;
var _enokiClient2;
var _state;
var _provider;
var _clientId;
var _redirectUrl;
var _extraParams;
var _getCurrentNetwork;
var _windowFeatures;
var _signTransaction;
var _signAndExecuteTransaction;
var _signPersonalMessage;
var _getMetadata;
var _getSession;
var _on;
var _connect;
var _disconnect;
var _EnokiWallet_instances;
var getAuthorizedAccounts_fn;
var getKeypair_fn;
var getSignerContext_fn;
var createSession_fn;
var getPKCEFlowContext_fn;
var createAuthorizationURL_fn;
var handleAuthCallback_fn;
var pkceTokenExchange_fn;
var pkceFlowProviders = {
  playtron: {
    tokenEndpoint: "https://oauth2.playtron.one/oauth2/token"
  }
};
var EnokiWallet = class {
  constructor({
    name,
    icon,
    provider,
    clientId,
    redirectUrl,
    extraParams,
    windowFeatures,
    getCurrentNetwork,
    apiKey,
    apiUrl,
    clients
  }) {
    __privateAdd9(this, _EnokiWallet_instances);
    __privateAdd9(this, _events);
    __privateAdd9(this, _accounts);
    __privateAdd9(this, _name);
    __privateAdd9(this, _icon);
    __privateAdd9(this, _enokiClient2);
    __privateAdd9(this, _state);
    __privateAdd9(this, _provider);
    __privateAdd9(this, _clientId);
    __privateAdd9(this, _redirectUrl);
    __privateAdd9(this, _extraParams);
    __privateAdd9(this, _getCurrentNetwork);
    __privateAdd9(this, _windowFeatures);
    __privateAdd9(this, _signTransaction, async ({ transaction, chain, account, signal }) => {
      signal == null ? void 0 : signal.throwIfAborted();
      const { client, keypair } = await __privateMethod6(this, _EnokiWallet_instances, getSignerContext_fn).call(this, chain);
      const parsedTransaction = Transaction.from(await transaction.toJSON());
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      parsedTransaction.setSenderIfNotSet(suiAddress);
      return keypair.signTransaction(await parsedTransaction.build({ client }));
    });
    __privateAdd9(this, _signAndExecuteTransaction, async ({
      transaction,
      chain,
      account,
      signal
    }) => {
      signal == null ? void 0 : signal.throwIfAborted();
      const { client, keypair } = await __privateMethod6(this, _EnokiWallet_instances, getSignerContext_fn).call(this, chain);
      const parsedTransaction = Transaction.from(await transaction.toJSON());
      const bytes = await parsedTransaction.build({ client });
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      parsedTransaction.setSenderIfNotSet(suiAddress);
      const result = await keypair.signAndExecuteTransaction({
        transaction: parsedTransaction,
        client
      });
      return {
        bytes: toBase64(bytes),
        signature: result.signatures[0],
        digest: result.digest,
        effects: toBase64(result.effects.bcs)
      };
    });
    __privateAdd9(this, _signPersonalMessage, async ({ message, account, chain }) => {
      const { keypair } = await __privateMethod6(this, _EnokiWallet_instances, getSignerContext_fn).call(this, chain);
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      return keypair.signPersonalMessage(message);
    });
    __privateAdd9(this, _getMetadata, () => {
      return {
        provider: __privateGet9(this, _provider)
      };
    });
    __privateAdd9(this, _getSession, async (input) => {
      const sessionContext = __privateGet9(this, _state).getSessionContext(
        (input == null ? void 0 : input.network) ?? __privateGet9(this, _getCurrentNetwork).call(this)
      );
      return await __privateGet9(this, _state).getSession(sessionContext);
    });
    __privateAdd9(this, _on, (event, listener) => {
      __privateGet9(this, _events).on(event, listener);
      return () => __privateGet9(this, _events).off(event, listener);
    });
    __privateAdd9(this, _connect, async (input) => {
      await allTasks();
      if ((input == null ? void 0 : input.silent) || __privateGet9(this, _accounts).length > 0) {
        return { accounts: __privateGet9(this, _accounts) };
      }
      const currentNetwork = __privateGet9(this, _getCurrentNetwork).call(this);
      await __privateMethod6(this, _EnokiWallet_instances, createSession_fn).call(this, { network: currentNetwork });
      return { accounts: __privateGet9(this, _accounts) };
    });
    __privateAdd9(this, _disconnect, async () => {
      await __privateGet9(this, _state).logout();
      __privateSet9(this, _accounts, []);
      __privateGet9(this, _events).emit("change", { accounts: __privateGet9(this, _accounts) });
    });
    __privateSet9(this, _events, mitt_default());
    __privateSet9(this, _name, name);
    __privateSet9(this, _icon, icon);
    __privateSet9(this, _enokiClient2, new EnokiClient({ apiKey, apiUrl }));
    __privateSet9(this, _state, new EnokiWalletState({ apiKey, clientId, clients }));
    __privateSet9(this, _provider, provider);
    __privateSet9(this, _clientId, clientId);
    __privateSet9(this, _redirectUrl, redirectUrl || window.location.href.split("#")[0]);
    __privateSet9(this, _extraParams, extraParams);
    __privateSet9(this, _windowFeatures, windowFeatures);
    __privateSet9(this, _getCurrentNetwork, getCurrentNetwork);
    __privateSet9(this, _accounts, []);
    __privateGet9(this, _state).zkLoginState.subscribe(() => {
      __privateSet9(this, _accounts, __privateMethod6(this, _EnokiWallet_instances, getAuthorizedAccounts_fn).call(this));
      __privateGet9(this, _events).emit("change", { accounts: __privateGet9(this, _accounts) });
    });
  }
  get name() {
    return __privateGet9(this, _name);
  }
  get provider() {
    return __privateGet9(this, _provider);
  }
  get icon() {
    return __privateGet9(this, _icon);
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return [...__privateGet9(this, _state).sessionContextByNetwork.keys()].map(
      (network) => `sui:${network}`
    );
  }
  get accounts() {
    return __privateGet9(this, _accounts);
  }
  get features() {
    return {
      [StandardConnect]: {
        version: "1.0.0",
        connect: __privateGet9(this, _connect)
      },
      [StandardDisconnect]: {
        version: "1.0.0",
        disconnect: __privateGet9(this, _disconnect)
      },
      [StandardEvents]: {
        version: "1.0.0",
        on: __privateGet9(this, _on)
      },
      [SuiSignTransaction]: {
        version: "2.0.0",
        signTransaction: __privateGet9(this, _signTransaction)
      },
      [SuiSignAndExecuteTransaction]: {
        version: "2.0.0",
        signAndExecuteTransaction: __privateGet9(this, _signAndExecuteTransaction)
      },
      [SuiSignPersonalMessage]: {
        version: "1.1.0",
        signPersonalMessage: __privateGet9(this, _signPersonalMessage)
      },
      [EnokiGetMetadata]: {
        version: "1.0.0",
        getMetadata: __privateGet9(this, _getMetadata)
      },
      [EnokiGetSession]: {
        version: "1.0.0",
        getSession: __privateGet9(this, _getSession)
      }
    };
  }
};
_events = /* @__PURE__ */ new WeakMap();
_accounts = /* @__PURE__ */ new WeakMap();
_name = /* @__PURE__ */ new WeakMap();
_icon = /* @__PURE__ */ new WeakMap();
_enokiClient2 = /* @__PURE__ */ new WeakMap();
_state = /* @__PURE__ */ new WeakMap();
_provider = /* @__PURE__ */ new WeakMap();
_clientId = /* @__PURE__ */ new WeakMap();
_redirectUrl = /* @__PURE__ */ new WeakMap();
_extraParams = /* @__PURE__ */ new WeakMap();
_getCurrentNetwork = /* @__PURE__ */ new WeakMap();
_windowFeatures = /* @__PURE__ */ new WeakMap();
_signTransaction = /* @__PURE__ */ new WeakMap();
_signAndExecuteTransaction = /* @__PURE__ */ new WeakMap();
_signPersonalMessage = /* @__PURE__ */ new WeakMap();
_getMetadata = /* @__PURE__ */ new WeakMap();
_getSession = /* @__PURE__ */ new WeakMap();
_on = /* @__PURE__ */ new WeakMap();
_connect = /* @__PURE__ */ new WeakMap();
_disconnect = /* @__PURE__ */ new WeakMap();
_EnokiWallet_instances = /* @__PURE__ */ new WeakSet();
getAuthorizedAccounts_fn = function() {
  const zkLoginState = __privateGet9(this, _state).zkLoginState.get();
  if (zkLoginState) {
    return [
      new ReadonlyWalletAccount({
        address: zkLoginState.address,
        chains: this.chains,
        icon: this.icon,
        features: [SuiSignPersonalMessage, SuiSignTransaction, SuiSignAndExecuteTransaction],
        publicKey: fromBase64(zkLoginState.publicKey)
      })
    ];
  }
  return [];
};
getKeypair_fn = async function(sessionContext) {
  const session = await __privateGet9(this, _state).getSession(sessionContext);
  if (!(session == null ? void 0 : session.jwt) || Date.now() > session.expiresAt) {
    await __privateMethod6(this, _EnokiWallet_instances, createSession_fn).call(this, { network: sessionContext.client.network });
  }
  const storedNativeSigner = await get(
    "ephemeralKeyPair",
    sessionContext.idbStore
  );
  if (!storedNativeSigner) {
    throw new Error("Native signer not found in store.");
  }
  const updatedSession = await __privateGet9(this, _state).getSession(sessionContext);
  if (!(updatedSession == null ? void 0 : updatedSession.jwt)) {
    throw new Error("Failed to retrieve an active session.");
  }
  const ephemeralKeypair = WebCryptoSigner.import(storedNativeSigner);
  const proof = updatedSession.proof ?? await __privateGet9(this, _enokiClient2).createZkLoginZkp({
    network: sessionContext.client.network,
    jwt: updatedSession.jwt,
    maxEpoch: updatedSession.maxEpoch,
    randomness: updatedSession.randomness,
    ephemeralPublicKey: ephemeralKeypair.getPublicKey()
  });
  await __privateGet9(this, _state).setSession(sessionContext, { ...updatedSession, proof });
  return new EnokiKeypair({
    address: this.accounts[0].address,
    maxEpoch: updatedSession.maxEpoch,
    ephemeralKeypair,
    proof
  });
};
getSignerContext_fn = async function(chain) {
  const sessionContext = chain ? __privateGet9(this, _state).getSessionContext(chain.split(":")[1]) : null;
  if (!sessionContext) {
    throw new Error(
      `A valid Sui chain identifier was not provided in the request. Please report this issue to the dApp developer. Examples of valid Sui chain identifiers are 'sui:testnet' and 'sui:mainnet'. Consider using the '@mysten/dapp-kit' package, which provides this value automatically.`
    );
  }
  const keypair = await __privateMethod6(this, _EnokiWallet_instances, getKeypair_fn).call(this, sessionContext);
  return { client: sessionContext.client, keypair };
};
createSession_fn = async function({ network }) {
  const popup = window.open(
    void 0,
    "_blank",
    typeof __privateGet9(this, _windowFeatures) === "function" ? __privateGet9(this, _windowFeatures).call(this) : __privateGet9(this, _windowFeatures)
  );
  if (!popup) {
    throw new Error("Failed to open popup");
  }
  const sessionContext = __privateGet9(this, _state).getSessionContext(network);
  const pkceContext = await __privateMethod6(this, _EnokiWallet_instances, getPKCEFlowContext_fn).call(this);
  popup.location = await __privateMethod6(this, _EnokiWallet_instances, createAuthorizationURL_fn).call(this, sessionContext, pkceContext);
  return await new Promise((resolve, reject) => {
    const interval = setInterval(() => {
      try {
        if (popup.closed) {
          clearInterval(interval);
          reject(new Error("Popup closed"));
        }
        if (!pkceContext && !popup.location.hash || pkceContext && !popup.location.search) {
          return;
        }
      } catch {
        return;
      }
      clearInterval(interval);
      __privateMethod6(this, _EnokiWallet_instances, handleAuthCallback_fn).call(this, {
        hash: popup.location.hash,
        sessionContext,
        search: popup.location.search,
        pkceContext
      }).then(() => resolve(), reject);
      try {
        popup.close();
      } catch (e) {
        console.error(e);
      }
    }, 16);
  });
};
getPKCEFlowContext_fn = async function() {
  if (!pkceFlowProviders[__privateGet9(this, _provider)]) {
    return;
  }
  const array = new Uint8Array(64);
  crypto.getRandomValues(array);
  const codeVerifier = toBase64(array).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  const codeChallenge = toBase64(
    new Uint8Array(await crypto.subtle.digest("SHA-256", new TextEncoder().encode(codeVerifier)))
  ).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  return { codeVerifier, codeChallenge };
};
createAuthorizationURL_fn = async function(sessionContext, pkceContext) {
  const ephemeralKeyPair = await WebCryptoSigner.generate();
  const { nonce, randomness, maxEpoch, estimatedExpiration } = await __privateGet9(this, _enokiClient2).createZkLoginNonce({
    network: sessionContext.client.network,
    ephemeralPublicKey: ephemeralKeyPair.getPublicKey()
  });
  const extraParams = typeof __privateGet9(this, _extraParams) === "function" ? __privateGet9(this, _extraParams).call(this) : __privateGet9(this, _extraParams);
  const params = new URLSearchParams({
    ...extraParams,
    nonce,
    client_id: __privateGet9(this, _clientId),
    redirect_uri: __privateGet9(this, _redirectUrl),
    response_type: "id_token",
    scope: ["openid", ...(extraParams == null ? void 0 : extraParams.scope) ? extraParams.scope.split(" ") : []].filter(Boolean).join(" "),
    ...pkceContext ? {
      response_type: "code",
      code_challenge_method: "S256",
      code_challenge: pkceContext.codeChallenge
    } : void 0
  });
  let oauthUrl;
  switch (__privateGet9(this, _provider)) {
    case "google":
      oauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
      break;
    case "facebook":
      oauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;
      break;
    case "twitch":
      params.set("force_verify", "true");
      oauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;
      break;
    case "onefc":
      oauthUrl = `https://login.onepassport.onefc.com/de3ee5c1-5644-4113-922d-e8336569a462/b2c_1a_prod_signupsignin_onesuizklogin/oauth2/v2.0/authorize?${params}`;
      break;
    case "playtron":
      oauthUrl = `https://oauth2.playtron.one/oauth2/auth?${params}`;
      break;
    default:
      throw new Error(`Invalid provider: ${__privateGet9(this, _provider)}`);
  }
  await set("ephemeralKeyPair", ephemeralKeyPair.export(), sessionContext.idbStore);
  await __privateGet9(this, _state).setSession(sessionContext, {
    expiresAt: estimatedExpiration,
    maxEpoch,
    randomness
  });
  return oauthUrl;
};
handleAuthCallback_fn = async function({
  hash,
  sessionContext,
  pkceContext,
  search
}) {
  const params = new URLSearchParams(hash.startsWith("#") ? hash.slice(1) : hash);
  const zkp = await __privateGet9(this, _state).getSession(sessionContext);
  if (!(zkp == null ? void 0 : zkp.maxEpoch) || !zkp.randomness) {
    throw new Error(
      "Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this."
    );
  }
  const jwt = pkceContext ? await __privateMethod6(this, _EnokiWallet_instances, pkceTokenExchange_fn).call(this, search, pkceContext) : params.get("id_token");
  if (!jwt) {
    throw new Error("Missing ID Token");
  }
  decodeJwt(jwt);
  const { address, publicKey } = await __privateGet9(this, _enokiClient2).getZkLogin({ jwt });
  __privateGet9(this, _state).zkLoginState.set({ address, publicKey });
  await __privateGet9(this, _state).setSession(sessionContext, { ...zkp, jwt });
  return params.get("state");
};
pkceTokenExchange_fn = async function(search, pkceContext) {
  var _a;
  const params = new URLSearchParams(search);
  const code = params.get("code");
  if (!code) {
    throw new Error("Missing code");
  }
  const tokenEndpoint = (_a = pkceFlowProviders[__privateGet9(this, _provider)]) == null ? void 0 : _a.tokenEndpoint;
  if (!tokenEndpoint) {
    throw new Error(`PKCE flow not supported for provider: ${__privateGet9(this, _provider)}`);
  }
  const response = await fetch(tokenEndpoint, {
    method: "POST",
    body: new URLSearchParams({
      grant_type: "authorization_code",
      client_id: __privateGet9(this, _clientId),
      redirect_uri: __privateGet9(this, _redirectUrl),
      code,
      code_verifier: pkceContext.codeVerifier
    })
  });
  return (await response.json()).id_token;
};

// node_modules/@mysten/enoki/dist/esm/utils.js
function isEnokiNetwork(network) {
  return network === "mainnet" || network === "testnet" || network === "devnet";
}

// node_modules/@mysten/enoki/dist/esm/wallet/providers.js
var ENOKI_PROVIDER_WALLETS_INFO = [
  {
    provider: "google",
    name: "Sign in with Google",
    icon: "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMyIiB2aWV3Qm94PSIwIDAgMzIgMzIiIHdpZHRoPSIzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMzIgMGgtMzJ2MzJoMzJ6IiBmaWxsPSIjZmZmIi8+PGcgY2xpcC1ydWxlPSJldmVub2RkIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Im0yMy44Mjk5IDE2LjE4MThjMC0uNTY3Mi0uMDUwOS0xLjExMjctLjE0NTQtMS42MzYzaC03LjUzNDZ2My4wOTQ1aDQuMzA1NWMtLjE4NTUgMS0uNzQ5MSAxLjg0NzMtMS41OTY0IDIuNDE0NnYyLjAwNzNoMi41ODU1YzEuNTEyNy0xLjM5MjggMi4zODU0LTMuNDQzNyAyLjM4NTQtNS44ODAxeiIgZmlsbD0iIzQyODVmNCIvPjxwYXRoIGQ9Im0xNi4xNDk2IDI0YzIuMTYgMCAzLjk3MDktLjcxNjQgNS4yOTQ2LTEuOTM4MmwtMi41ODU1LTIuMDA3M2MtLjcxNjQuNDgtMS42MzI3Ljc2MzYtMi43MDkxLjc2MzYtMi4wODM2IDAtMy44NDczLTEuNDA3Mi00LjQ3NjQtMy4yOTgxaC0yLjY3MjcxdjIuMDcyN2MxLjMxNjQxIDIuNjE0NSA0LjAyMTgxIDQuNDA3MyA3LjE0OTExIDQuNDA3M3oiIGZpbGw9IiMzNGE4NTMiLz48cGF0aCBkPSJtMTEuNjczNSAxNy41MmMtLjE2LS40OC0uMjUwOS0uOTkyOC0uMjUwOS0xLjUyIDAtLjUyNzMuMDkwOS0xLjA0LjI1MDktMS41MnYtMi4wNzI4aC0yLjY3MjY5Yy0uNTQxODIgMS4wOC0uODUwOTEgMi4zMDE4LS44NTA5MSAzLjU5MjggMCAxLjI5MDkuMzA5MDkgMi41MTI3Ljg1MDkxIDMuNTkyN3oiIGZpbGw9IiNmYmJjMDUiLz48cGF0aCBkPSJtMTYuMTQ5NiAxMS4xODE4YzEuMTc0NSAwIDIuMjI5MS40MDM3IDMuMDU4MiAxLjE5NjRsMi4yOTQ1LTIuMjk0NmMtMS4zODU0LTEuMjkwODctMy4xOTYzLTIuMDgzNi01LjM1MjctMi4wODM2LTMuMTI3MyAwLTUuODMyNyAxLjc5MjczLTcuMTQ5MTEgNC40MDczbDIuNjcyNzEgMi4wNzI3Yy42MjkxLTEuODkwOSAyLjM5MjgtMy4yOTgyIDQuNDc2NC0zLjI5ODJ6IiBmaWxsPSIjZWE0MzM1Ii8+PC9nPjwvc3ZnPg=="
  },
  {
    provider: "facebook",
    name: "Sign in with Facebook",
    icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgZmlsbD0iIzE4NzdGMiIgdmVyc2lvbj0iMS4wIiB2aWV3Qm94PSIwIDAgMjA4NCAyMDg0Ij48cGF0aCBkPSJNOTkyIDJDODU4LjcgOS4xIDczNi42IDM4LjEgNjE5IDkwLjVjLTI4NS41IDEyNy4yLTQ5OS4xIDM3NS45LTU4MS41IDY3Ny0yNS45IDk0LjYtMzcuOCAxOTAuMi0zNi4yIDI5MSAuOCA0Ni43IDIuOCA3NS4zIDguMyAxMTguNSAxNi4xIDEyNi42IDU2LjcgMjUxLjUgMTE4IDM2My44IDEwMS44IDE4NiAyNTYuOSAzMzYuMiA0NDUuOSA0MzEuNyA2Mi4xIDMxLjMgMTI3LjggNTYuNiAxOTMgNzQuMyA5LjkgMi43IDE5LjIgNS4yIDIwLjggNS42bDIuNy42di02OTJsLTEwNy4yLS4yLTEwNy4zLS4zdi0zMThsMTA3LjEtLjMgMTA3LjItLjIuNS05Mi44Yy41LTkwIC45LTEwMyA0LjMtMTM5LjIgMTctMTgzLjIgOTAtMzA1LjUgMjIwLjUtMzY5LjUgNTguNy0yOC44IDEyOC4zLTQ1LjcgMjE1LjktNTIuNSAyMi44LTEuOCA4Mi40LTIuNCAxMDYtMS4xIDU3LjEgMy4yIDEyMC40IDEwLjYgMTYzIDE5LjEgMTAuNyAyLjIgMjAuOSA0LjMgMjIuNSA0LjhsMyAuOC4zIDE0NC45LjIgMTQ0LjgtNi4yLS42Yy0yOS4zLTMtMTMzLjEtNC4yLTE1OC4zLTEuOS02NS42IDYtMTA4LjYgMjIuMy0xMzkgNTIuNy0yMi45IDIyLjktMzcuOCA1My00NS45IDkyLjgtNi40IDMxLjEtNy42IDUyLjgtNy42IDEzMi45djY0LjhoMTcwYzkzLjUgMCAxNzAgLjQgMTcwIC44IDAgLjUtMTMgNzEuOS0yOSAxNTguNy0xNS45IDg2LjgtMjkgMTU4LjItMjkgMTU4LjcgMCAuNC02My40LjgtMTQxIC44aC0xNDF2MzU3LjVjMCAyODUuMy4zIDM1Ny41IDEuMyAzNTcuNSAzLjMgMCA0NC43LTYuNCA2MS42LTkuNSAxNjMtMjkuOSAzMTYuNy05OC44IDQ0OS4xLTIwMS40IDU1LjgtNDMuMiAxMTMuOS05OS4xIDE1OS42LTE1My43IDQxLjMtNDkuMSA4MC41LTEwNi4yIDExMi44LTE2My45IDE5LjctMzUuMiA0Ny05My42IDYxLjctMTMyLjMgNzAuNi0xODQuOCA4Ny4yLTM4Ni4xIDQ3LjgtNTgxLjUtNDUuNy0yMjYuNi0xNjkuNC00MzUuNi0zNDYuOS01ODUuOC0xNDQuNS0xMjIuMi0zMTYuNC0yMDItNTAxLjUtMjMyLjktMzEuMy01LjItNjYuNC05LjItMTA0LTEyLTE4LjMtMS40LTk4LjctMi4xLTExOC41LTF6Ii8+PC9zdmc+"
  },
  {
    provider: "twitch",
    name: "Sign in with Twitch",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuNiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiCgl2aWV3Qm94PSItNDAwIC00MDAgMjgwMCAzMjAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj4KCTxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+CgkJLnN0MCB7CgkJCWZpbGw6ICNGRkZGRkY7CgkJfQoKCQkuc3QxIHsKCQkJZmlsbDogIzkxNDZGRjsKCQl9Cgk8L3N0eWxlPgoJPHRpdGxlPkFzc2V0IDI8L3RpdGxlPgoJPGc+CgkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIyMjAwLDEzMDAgMTgwMCwxNzAwIDE0MDAsMTcwMCAxMDUwLDIwNTAgMTA1MCwxNzAwIDYwMCwxNzAwIDYwMCwyMDAgMjIwMCwyMDAgCSIgLz4KCQk8Zz4KCQkJPGcgaWQ9IkxheWVyXzEtMiI+CgkJCQk8cGF0aCBjbGFzcz0ic3QxIiBkPSJNNTAwLDBMMCw1MDB2MTgwMGg2MDB2NTAwbDUwMC01MDBoNDAwbDkwMC05MDBWMEg1MDB6IE0yMjAwLDEzMDBsLTQwMCw0MDBoLTQwMGwtMzUwLDM1MHYtMzUwSDYwMFYyMDBoMTYwMAoJCQkJVjEzMDB6IiAvPgoJCQkJPHJlY3QgeD0iMTcwMCIgeT0iNTUwIiBjbGFzcz0ic3QxIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjYwMCIgLz4KCQkJCTxyZWN0IHg9IjExNTAiIHk9IjU1MCIgY2xhc3M9InN0MSIgd2lkdGg9IjIwMCIgaGVpZ2h0PSI2MDAiIC8+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+Cjwvc3ZnPgo="
  },
  {
    provider: "onefc",
    name: "Sign in with ONE Championship",
    icon: "data:image/png;base64,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"
  },
  {
    provider: "playtron",
    name: "Sign in with Playtron",
    icon: "data:image/png;base64,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"
  }
];

// node_modules/@mysten/enoki/dist/esm/wallet/register.js
function registerEnokiWallets({
  providers,
  windowFeatures = defaultWindowFeatures,
  ...config
}) {
  const clients = "clients" in config ? config.clients : [Object.assign(config.client, { network: config.network ?? "mainnet" })];
  const enokiCompatibleClients = clients.filter(({ network }) => isEnokiNetwork(network));
  if (enokiCompatibleClients.length === 0) {
    throw new Error("None of the specified clients are compatible with Enoki.");
  }
  const getCurrentNetwork = "clients" in config ? config.getCurrentNetwork : () => clients[0].network;
  const walletsApi = getWallets();
  const wallets = {};
  for (const { name, icon, provider } of ENOKI_PROVIDER_WALLETS_INFO) {
    const providerOptions = providers[provider];
    if (providerOptions) {
      wallets[provider] = new EnokiWallet({
        ...providerOptions,
        name,
        icon,
        provider,
        windowFeatures,
        getCurrentNetwork,
        apiKey: config.apiKey,
        apiUrl: config.apiUrl,
        clients: enokiCompatibleClients
      });
    }
  }
  const unregister = walletsApi.register(...Object.values(wallets));
  return { wallets, unregister };
}
function defaultWindowFeatures() {
  const width = 500;
  const height = 800;
  const left = (screen.width - width) / 2;
  const top = (screen.height - height) / 4;
  return `popup=1;toolbar=0;status=0;resizable=1,width=${width},height=${height},top=${top},left=${left}`;
}

// node_modules/@mysten/enoki/dist/esm/wallet/initializer.js
function enokiWalletsInitializer(options) {
  return {
    id: "enoki-wallets-initializer",
    async initialize({
      networks,
      getClient
    }) {
      const { unregister } = registerEnokiWallets({
        ...options,
        getCurrentNetwork: () => getClient().network,
        clients: networks.map(getClient)
      });
      return { unregister };
    }
  };
}

// node_modules/@wallet-standard/ui-registry/lib/esm/UiWalletHandleRegistry_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.js
var uiWalletHandlesToWallets = /* @__PURE__ */ new WeakMap();
function getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletHandle) {
  const wallet = uiWalletHandlesToWallets.get(uiWalletHandle);
  if (!wallet) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND);
    safeCaptureStackTrace(err, getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);
    throw err;
  }
  return wallet;
}

// node_modules/@wallet-standard/ui-features/lib/esm/getWalletFeature.js
function getWalletFeature(uiWalletHandle, featureName) {
  const wallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletHandle);
  if (!(featureName in wallet.features)) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED, {
      featureName,
      supportedChains: [...wallet.chains],
      supportedFeatures: Object.keys(wallet.features),
      walletName: wallet.name
    });
    safeCaptureStackTrace(err, getWalletFeature);
    throw err;
  }
  return wallet.features[featureName];
}

// node_modules/@mysten/enoki/dist/esm/wallet/utils.js
function isEnokiWallet(wallet) {
  if (isWalletHandle(wallet)) {
    return wallet.features.includes(EnokiGetMetadata);
  }
  return EnokiGetMetadata in wallet.features;
}
function getWalletMetadata(wallet) {
  if (isWalletHandle(wallet)) {
    try {
      const { getMetadata } = getWalletFeature(
        wallet,
        EnokiGetMetadata
      );
      return getMetadata();
    } catch {
      return null;
    }
  } else if (EnokiGetMetadata in wallet.features) {
    const walletWithFeature = wallet;
    return walletWithFeature.features[EnokiGetMetadata].getMetadata();
  }
  return null;
}
async function getSession(wallet, input) {
  if (isWalletHandle(wallet)) {
    try {
      const { getSession: getSession2 } = getWalletFeature(
        wallet,
        EnokiGetSession
      );
      return await getSession2(input);
    } catch {
      return null;
    }
  } else if (EnokiGetSession in wallet.features) {
    const walletWithFeature = wallet;
    return await walletWithFeature.features[EnokiGetSession].getSession(input);
  }
  return null;
}
function isGoogleWallet(wallet) {
  var _a;
  return ((_a = getWalletMetadata(wallet)) == null ? void 0 : _a.provider) === "google";
}
function isTwitchWallet(wallet) {
  var _a;
  return ((_a = getWalletMetadata(wallet)) == null ? void 0 : _a.provider) === "twitch";
}
function isFacebookWallet(wallet) {
  var _a;
  return ((_a = getWalletMetadata(wallet)) == null ? void 0 : _a.provider) === "facebook";
}
function isWalletHandle(wallet) {
  return Array.isArray(wallet.features);
}
export {
  EnokiClient,
  EnokiClientError,
  EnokiFlow,
  EnokiKeypair,
  EnokiPublicKey,
  createDefaultEncryption,
  createInMemoryStorage,
  createLocalStorage,
  createSessionStorage,
  enokiWalletsInitializer,
  getSession,
  getWalletMetadata,
  isEnokiNetwork,
  isEnokiWallet,
  isFacebookWallet,
  isGoogleWallet,
  isTwitchWallet,
  registerEnokiWallets
};
/*! Bundled license information:

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@mysten_enoki.js.map
